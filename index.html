<!doctype html>
<html class="theme-next use-motion ">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="学习总结 思考感悟 知识管理" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="Codingforever">
<meta property="og:url" content="http://codingforever.com/index.html">
<meta property="og:site_name" content="Codingforever">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codingforever">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

    <title> Codingforever </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Codingforever</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/02/14//2015/02-14-0.html/" itemprop="url">
                经典算法巡礼(八) -- 查找之二叉查找树
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-02-14T00:00:00+08:00" content="2月 14 2015">
            2月 14 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="理论说">理论说</h2><h3 id="概念">概念</h3><p><a href="http://zh.wikipedia.org/zh/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">二叉查找树</a>是计算机科学中最重要的算法之一，它将<a href="http://zh.wikipedia.org/zh/%E9%93%BE%E8%A1%A8" target="_blank" rel="external">链表</a>插入的灵活性和<a href="http://baike.baidu.com/view/3792536.htm" target="_blank" rel="external">有序数组</a>查找的高效性结合在一起，即同时拥有插入灵活性和查找高效性的一种符号表实现。</p>
<h3 id="性能">性能</h3><p>我们知道，链表以插入灵活性闻名，但是它的实现直接导致在查找效率上不是如此优美，<strong>平均情况下的成本数量级为O(N/2)，最坏情况下为O(N)</strong>。而有序数组查找时利用二分法直接将查找效率提高至<strong>平均情况和最坏情况均为对数级别O(lgN)</strong>，而查找情况下却也丑陋不堪，<strong>平均情况下增长数量级为O(N/2)，最坏情况下为O(N)</strong>。二叉查找树结合两者的优势，<strong>在平均情况下查找和插入均提高至O(lgN)，最坏情况下为O(N)</strong>。</p>
<h3 id="数据结构">数据结构</h3><p>二叉查找树所使用的数组结构由结点组成，每个结点均包含指向其他指点的指针(可以为空)。在二叉树中，每个结点有且只能有一个父结点，即只能有一个另外的结点包含指向该结点的指针(树的根结点除外)，而每个结点都有左右两个分别指向不同结点的指针，称之为左子指针和右子指针，被指向的两个结点分别为该结点的左子结点和右子结点(可以为nil，即没有相应的子结点)。同时，二叉查找树有一个重要的性质，即结点的左子结点及其左子结点的所有递归子结点的值均小于该结点，而右子结点及其右子结点的所有递归所有子结点的值均大于该结点。这个特性使得该树成为一个按一定方式有序的树，从而支持高效查询。</p>
<p>一棵典型的二叉查找树如下图所示：</p>
<p><img src="/img/2015-02-14-0.png" alt=""></p>
<p>如图中所示，结点S为二叉查找树的根结点，它是没有父结点的，但是拥有两个子结点，左子结点为E，父子结点为X。同时，结点E又拥有两个子结点，而结点X没有子结点。另外，由于二叉查找树的性质，结点S,E,X的大小 为E&lt;S&lt;X。</p>
<h2 id="实践说">实践说</h2><p>我们实现二叉查找树中几个常用的接口，均以golang实现。</p>
<h3 id="结点定义">结点定义</h3><p>我们首先定义结点的数据结构，根据<strong>“理论说”</strong>中表述，结点必须包含指向左子结点和右子结点的两个指针。另外，结点是数据承载的容器，所以还必须包括与数据相关的字段。我们将结点定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Key <span class="typename">string</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="typename">string</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	key         Key</span><br><span class="line">	value       Value</span><br><span class="line">	left, right *Node</span><br><span class="line">	N           <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述结构中，我们包含了指向子结点的两个指针，而且具有一对Key-Value对，这表明我们结点中所存储数据为Key-Value对，另外N为结点计数器，值为以该结点为根结点的子树的结点总数，如<strong>“基础说”</strong>中E结点的N值为5。</p>
<h3 id="二叉查找树定义">二叉查找树定义</h3><p>定义二叉查找树，有了<strong>“结点定义”</strong>后，该定义非常方便，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BST <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码段明显可知，二叉查找树的定义，只要直接保存其根结点即可。</p>
<h3 id="二叉查找树一般性接口定义">二叉查找树一般性接口定义</h3><p>一般来说，二叉查找树具有以下几个类型的接口：</p>
<ul>
<li>Size：二叉查找树结点数</li>
<li>Get：从二叉查找树中获取相应的值</li>
<li>Put：将相应的值插入到二叉查找树中</li>
<li>Min：从二叉查找树中获取最小值</li>
<li>Max：从二叉查找树中获取最大值</li>
<li>Floor：从二叉查找树中获取比给定值小的且是最大的值，即向下取整</li>
<li>Ceiling：从二叉查找树中获比给定值大的且是最小的值，即向上取整</li>
<li>Select：从二叉查找树中获取第k个结点的值（从0开始）</li>
<li>Rank: Select接口的反操作，即从二叉查找树中获取给定值的结点的排序值</li>
<li>DeleteMin：删除二叉查找树中最小值</li>
<li>DeleteMax：删除二叉查找树中最大值</li>
<li>Delete：删除指定结点</li>
<li>Travel: 遍历二叉查找树</li>
</ul>
<h3 id="接口实现：Size">接口实现：Size</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Size() <span class="typename">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.size(this.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) size(n *Node) <span class="typename">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.N</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们在定义结点结构体的时候，特别增加字段N表示以该结点为根结点的子树的结点数，所以Size()接口的实现非常方便，直接返回N字段的值即可。</p>
<h3 id="接口实现：Get">接口实现：Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Get(key Key) *Node &#123;</span><br><span class="line">	<span class="keyword">return</span> this.get(this.root, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) get(n *Node, key Key) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key &gt; key &#123;</span><br><span class="line">		<span class="keyword">return</span> this.get(n.left, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key &lt; key &#123;</span><br><span class="line">		<span class="keyword">return</span> this.get(n.right, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Get()接口的实现思路比较简单，递归遍历所有结点，若寻找Key的值等于结点的值，则找到相应结点；若小于结点的值，则在该结点的左子结点上再次进行相同的操作；若大于结点的值，则相应查看右子结点。</p>
<h3 id="接口实现：Put">接口实现：Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Put(key Key, value Value) &#123;</span><br><span class="line">	this.root = this.put(this.root, key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) put(n *Node, key Key, value Value) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Node&#123;key: key, value: value, N: <span class="number">1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key == key &#123;</span><br><span class="line">		n.value = value</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.key &lt; key &#123;</span><br><span class="line">		n.right = this.put(n.right, key, value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n.left = this.put(n.left, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">	n.N = this.size(n.left) + this.size(n.right) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Put()接口的实现思路可以归纳为两种情况：一种是找到相应结点并修改值，另一种是未找到相应结点，在合适的位置增加结点。具体实现时，递归比较结点值，若值相等，则为情况一。若值大于，则对结点左子树进行相同操作，若值小于，则对结点右子树进行相同操作，直到子结点为nil为止，即未找到相应结点，对应于情况二，则主动在该位置增加新结点。</p>
<h3 id="接口实现：Min">接口实现：Min</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Min() Key &#123;</span><br><span class="line">	<span class="keyword">return</span> this.min(this.root).key</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) min(n *Node) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.left != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> this.min(n.left)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Min()接口实现比较简单，由于二叉查找树本身的特点是有序的，所以直接一直找到最深左子结点即可。</p>
<h3 id="接口实现：Max">接口实现：Max</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Max() Key &#123;</span><br><span class="line">	<span class="keyword">return</span> this.max(this.root).key</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) max(n *Node) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.right != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> this.max(n.right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Max()接口与Min()接口类似，这里不再赘述。</p>
<h3 id="接口实现：Floor">接口实现：Floor</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Floor(key Key) Key &#123;</span><br><span class="line">	<span class="keyword">if</span> n := this.floor(this.root, key); n != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.key</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) floor(n *Node, key Key) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key == n.key &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key &lt; n.key &#123;</span><br><span class="line">		<span class="keyword">return</span> this.floor(n.left, key)</span><br><span class="line">	&#125;</span><br><span class="line">	node := this.floor(n.right, key)</span><br><span class="line">	<span class="keyword">if</span> node == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Floor()接口实现思路如下：如果给定Key等于结点的Key，则该结点为向下取整后结点，这种情况是最简单的；如果给定Key小于结点的Key，则向下取整后结点一定存在于以结点左子结点为根结点的子树中，递归调用即可；剩下的情况就是大于结点Key的情况，在此种情况下，向下取整后结点可能在右子树中，若不在，则该结点即为所需要结点。</p>
<h3 id="接口实现：Ceiling">接口实现：Ceiling</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Ceiling(key Key) Key &#123;</span><br><span class="line">	<span class="keyword">if</span> n := this.ceiling(this.root, key); n != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.key</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) ceiling(n *Node, key Key) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key == n.key &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key &gt; n.key &#123;</span><br><span class="line">		<span class="keyword">return</span> this.ceiling(n.right, key)</span><br><span class="line">	&#125;</span><br><span class="line">	node := this.ceiling(n.left, key)</span><br><span class="line">	<span class="keyword">if</span> node == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ceiling()接口与Floor()接口类似，也不再赘述。</p>
<h3 id="接口实现：Select">接口实现：Select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Select(k <span class="typename">int</span>) Key &#123;</span><br><span class="line">	<span class="keyword">if</span> n := this.innerSelect(this.root, k); n != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.key</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在go中select为关键字，所以以innerSelect代替</span></span><br><span class="line"><span class="keyword">func</span> (this *BST) innerSelect(n *Node, k <span class="typename">int</span>) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.left == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> this.innerSelect(n.right, k-<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.left.N == k &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.left.N &gt; k &#123;</span><br><span class="line">		<span class="keyword">return</span> this.innerSelect(n.left, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.left.N &lt; k &#123;</span><br><span class="line">		<span class="keyword">return</span> this.innerSelect(n.right, k-n.left.N-<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Select()接口实现的是给定一个k值，找到这样一个结点，小于这个结点的所有结点数正好为k。由于我们定义结点数据结构时，字段N的值代码以该结点为根结点形成的树的结点数。因此，Select()接口的实现只有找到这样一个结点，该结点的左子结点的N值为k即可。</p>
<h3 id="接口实现：Rank">接口实现：Rank</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Rank(key Key) <span class="typename">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.rank(this.root, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) rank(n *Node, key Key) <span class="typename">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key == key &#123;</span><br><span class="line">		<span class="keyword">if</span> n.left != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.left.N</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key &gt; key &#123;</span><br><span class="line">		<span class="keyword">return</span> this.rank(n.left, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key &lt; key &#123;</span><br><span class="line">		<span class="keyword">if</span> n.left != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.left.N + <span class="number">1</span> + this.rank(n.right, key)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span> + this.rank(n.right, key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rank()接口即Select()接口的反操作，即找到给比定结点小的结点数。实现过程中可以分为三种情况：结点值与Key相等时，结果为结点左子结点的N值；大于Key时，保存结果的结点在该结点的左子树中；小于Key时，情况略微复杂，由三部分组成，分别为左子树的结点数，该结点和右子树中比Key小的结点数。</p>
<h3 id="接口实现：DeleteMin">接口实现：DeleteMin</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) DeleteMin() &#123;</span><br><span class="line">	this.root = this.deleteMin(this.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) deleteMin(n *Node) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.left == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.right</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n.left = this.deleteMin(n.left)</span><br><span class="line">		n.N = this.size(n.left) + this.size(n.right) + <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DeleteMin()接口实现思路就是找到最小结点，并且删除它即可。根据二叉查找树的特点，最小结点只要沿着树的左子结点走，直到发现一个结点，其左子结点为nil，那么该结点就是最小结点。</p>
<h3 id="接口实现：DeleteMax">接口实现：DeleteMax</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) DeleteMax() &#123;</span><br><span class="line">	this.root = this.deleteMax(this.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) deleteMax(n *Node) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n.right == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.left</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n.right = this.deleteMax(n.right)</span><br><span class="line">		n.N = this.size(n.left) + this.size(n.right) + <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DeleteMax()接口与DeleteMin()接口类似，这里不再赘述。</p>
<h3 id="接口实现：Delete">接口实现：Delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (this *BST) Delete(key Key) &#123;</span><br><span class="line">	this.root = this.<span class="built_in">delete</span>(this.root, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) <span class="built_in">delete</span>(n *Node, key Key) *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.key &gt; key &#123;</span><br><span class="line">		n.left = this.<span class="built_in">delete</span>(n.left, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.key &lt; key &#123;</span><br><span class="line">		n.right = this.<span class="built_in">delete</span>(n.right, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n.left == <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.right</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.right == <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.left</span><br><span class="line">		&#125;</span><br><span class="line">		node := n</span><br><span class="line">		n = this.min(n.right)</span><br><span class="line">		n.right = this.deleteMin(n)</span><br><span class="line">		n.left = node.left</span><br><span class="line">	&#125;</span><br><span class="line">	n.N = this.size(n.left) + this.size(n.right) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delete()接口实现与查找类似，若结点值大于Key，则对结点左子数据进行递归操作，若结点值小于Key，则对结点右子数进行递归操作，当结点值等于Key时，则将该结点删除即可。在删除过程中，思路也很简单，即将删除结点的右子树中的最小结点代替该结点即可。</p>
<h3 id="接口实现：Travel">接口实现：Travel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> oper <span class="keyword">func</span>(*Node)</span><br><span class="line"><span class="keyword">func</span> (this *BST) Travel(f oper, sort <span class="typename">string</span>) &#123;</span><br><span class="line">	this.travel(this.root, f, sort)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (this *BST) travel(n *Node, f oper, sort <span class="typename">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> sort &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"in-order"</span>:</span><br><span class="line">		this.travel(n.left, f, sort)</span><br><span class="line">		f(n)</span><br><span class="line">		this.travel(n.right, f, sort)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"pre-order"</span>:</span><br><span class="line">		f(n)</span><br><span class="line">		this.travel(n.left, f, sort)</span><br><span class="line">		this.travel(n.right, f, sort)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"post-order"</span>:</span><br><span class="line">		this.travel(n.left, f, sort)</span><br><span class="line">		this.travel(n.right, f, sort)</span><br><span class="line">		f(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Travel接口实现考虑了三种情况，即<a href="http://zh.wikipedia.org/zh/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="external">中序遍历，先序遍历和后序遍历</a>。</p>
<h2 id="分析说">分析说</h2><p>使用二叉查找树的算法的<strong>运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序</strong>。在最好的情况下，二叉查找树是完全平衡的，每条空链接和根结点的距离都为~lgN，但是在最坏的情况下，二叉查找树与链表无异，具体参见下图：</p>
<p><img src="/img/2015-02-14-1.png" alt=""></p>
<p>但是，二叉查找树的形状由于取决于键被插入的先后顺序，所以我们无法控制其一直保持基本平衡状态。那么，<strong>我们是否可以如同<a href="http://codingforever.com/2014/12/28/-2014-12-28-1-html/">快速排序</a>一般事先进行随机打乱呢？事实上这是不行的，因为二叉查找树本身是有序的，而且它携带着键值的插入顺序</strong>。</p>
<p>为了方便我们分析，我们假设二叉查找树的键的分布是随机的，即它们插入的顺序是随机的。这里，我们直接引入两个命题：</p>
<pre><code>命题一：在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为~<span class="number">2l</span>nN(约<span class="number">1.39l</span>gN)。

命题二：在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~<span class="number">2l</span>nN(约<span class="number">1.39l</span>gN)。
</code></pre><p>命题一说明，<strong>二叉查找树在查找随机键的成本方面比二分查找大约高出39%(二分查找为lnN)</strong>，但是这高出的成本是值得的。因为命题二说明，<strong>二叉查找树在插入新键方面也是~2lnN，与二分查找的~N相比，对数级别的成本相对来说是高效很多</strong>。</p>
<p>以上分析均是基于二叉查找树的正常情况，而实际上，最坏情况也是可能发生的。<strong>在最坏情况下，二叉查找树的性能完全取决于树的高度</strong>，具体如命题三所描述。</p>
<pre><code>命题三：在一棵二叉查找树中，所有操作在最坏情况下所需要的时间都和树的高度成正比。
</code></pre><p>很明显，最坏情况下成本（即树的高度）一定会大于平均情况下的成本。但是具体是多少呢？事实上，<strong>随机键构造的二叉查找树的平均高度为树中结点数的对数级别，具体值趋近于2.99lgN</strong>。因此，<strong>二叉查找树的所有操作，在最坏情况下所需成本也是对数级别的</strong>，这不得不说是一个可喜的结果。</p>
<p>但是，请注意，我们之前有个假设：<strong>二叉查找树的键是随机插入的</strong>，但是实际应用中，这通常是理想情况下才会发生的事。而且，这种非随机插入，我们并不能如快速排序一般事先进行随机打乱操作。那么，真的无能为力了吗？当然不是！<a href="">平衡查找树</a>就是为这个而生的！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/02/01//2015/02-01-0.html/" itemprop="url">
                构建高性能服务器 -- 数据库篇
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-02-01T00:00:00+08:00" content="2月 1 2015">
            2月 1 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/服务器编程/" itemprop="url" rel="index"><span itemprop="name">服务器编程</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="写在前面">写在前面</h2><p>服务器数据，如用户相关数据，都需要保存起来，随时取出再次使用。当然，现在的<a href="http://zh.wikipedia.org/zh/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">内存数据库</a>也已经发展到相对可靠的阶段了，但是，我们这里还是讨论一个传统关系型数据库在构建高性能服务器方面的使用，如MySQL。</p>
<h2 id="利其器">利其器</h2><h3 id="友好的MySQL状态报告">友好的MySQL状态报告</h3><p>俗话说，工欲善其事，必先利其器。所以，在服务器端数据库性能优化方面，我们先介绍下一个利器 — <a href="http://www.tin.org/bin/man.cgi?section=1&amp;topic=mysqlreport" target="_blank" rel="external">mysqlreport</a>。</p>
<p>当然，在MySQL命令行中，我们可获取当前数据库的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status;</span><br><span class="line">mysql&gt; show innodb status;</span><br></pre></td></tr></table></figure>
<p>那么还需要mysqlreport干什么呢？当然，身为资深码农，我们一直以高标准要求，所以<strong>mysqlreport是一款友好方式的数据库状态检测工具</strong>，各方面甩直白的MySQL命令行好几条街。</p>
<p>我们利用mysqlreport获取下当前状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysqlreport --user USER_NAME --password PASSWORD</span><br></pre></td></tr></table></figure>
<p>具体状态结果很长，就不放了，有兴趣的同学可以自己去试下。</p>
<h3 id="解释查询">解释查询</h3><p>SQL语句的性能如何该如何知晓呢？<strong>解释查询explain</strong>横空出世。</p>
<p>explain的使用方式非常简单，举个简单例子，我们用以下语句创建数据表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="built_in">test</span> (</span><br><span class="line">	id int(<span class="number">11</span>) not null auto_increment,</span><br><span class="line">	name varchar(<span class="number">255</span>) not null,</span><br><span class="line">	primary key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后我们用存储过程向test数据表中增加一些数据。首先创建function:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter //&#10;create function rs(n int)&#10;returns varchar(255)&#10;begin&#10;&#9;declare chars char(26) default &#39;abcdefghijklmnopqrstuvwxyz&#39;;&#10;&#9;declare res varchar(1024) default &#39;&#39;;&#10;&#9;declare i int default 0;&#10;&#9;repeat&#10;&#9;set i = i + 1;&#10;&#9;set res = concat(res, substring(chars, floor(1 + rand() * 26), 1));&#10;&#9;until i = n end repeat;&#10;&#9;return res;&#10;end&#10;//</span><br></pre></td></tr></table></figure>
<p>然后创建存储过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line">create procedure inst(n int)</span><br><span class="line">begin</span><br><span class="line">	<span class="built_in">declare</span> i int default <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line">	repeat</span><br><span class="line">	<span class="built_in">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">	insert into <span class="built_in">test</span> <span class="built_in">set</span> name=rs(<span class="number">16</span>);</span><br><span class="line">	until i = n end repeat;</span><br><span class="line">	commit;</span><br><span class="line">	<span class="built_in">set</span> autocommit = <span class="number">1</span>;</span><br><span class="line">end</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<p>最后调用新创建的存储过程inst：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call inst(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<p>这时，我们已向数据表中插入了10W条数据。这时，我们对该数据表中数据进行查询，看下效率如何该怎么办呢？我们利用<strong>explain</strong>语句进行查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> id = <span class="number">999</span>;</span><br></pre></td></tr></table></figure>
<p>得到结果如下：</p>
<pre><code>+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|<span class="string"> id </span>|<span class="string"> select_type </span>|<span class="string"> table </span>|<span class="string"> type  </span>|<span class="string"> possible_keys </span>|<span class="string"> key     </span>|<span class="string"> key_len </span>|<span class="string"> ref   </span>|<span class="string"> rows </span>|<span class="string"> extra </span>|
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|<span class="string">  1 </span>|<span class="string"> simple      </span>|<span class="string"> test  </span>|<span class="string"> const </span>|<span class="string"> primary       </span>|<span class="string"> primary </span>|<span class="string"> 4       </span>|<span class="string"> const </span>|<span class="string">    1 </span>|<span class="string">       </span>|
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
</code></pre><p>我们可以看到，结果中type为const，这表示这次查询通过索引直接找到一个匹配行，优化器认为它的时间复杂度为常量。而根据key的值primary，意味着这次查询使用了主键索引。</p>
<p>然后我们利用<strong>explain</strong>语句查看另外的查询语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from test where name = &#39;yoxxwmxbpvhyxtyo&#39;;&#39;</span><br></pre></td></tr></table></figure>
<p>得到结果为：</p>
<pre><code>+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|<span class="string"> id </span>|<span class="string"> select_type </span>|<span class="string"> table </span>|<span class="string"> type </span>|<span class="string"> possible_keys </span>|<span class="string"> key  </span>|<span class="string"> key_len </span>|<span class="string"> ref  </span>|<span class="string"> rows   </span>|<span class="string"> Extra       </span>|
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|<span class="string">  1 </span>|<span class="string"> SIMPLE      </span>|<span class="string"> test  </span>|<span class="string"> ALL  </span>|<span class="string"> NULL          </span>|<span class="string"> NULL </span>|<span class="string"> NULL    </span>|<span class="string"> NULL </span>|<span class="string"> 100260 </span>|<span class="string"> Using where </span>|
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
</code></pre><p>与之前不同的是，这里type值为all，即本次查询采用了全表扫描，而key的值为null，这也理所当然，因为我们并没有将name增加索引。</p>
<p>经过上述简要讲述，大家应该了解到，<strong>explain</strong>语句在数据库优化过程中的确是一把利刃。</p>
<h3 id="慢查询分析">慢查询分析</h3><p>在开发环境中，我们可以对所有查询语句进行explain分析，并建立适当的索引，把数据库性能调至最优。但是，在正式环境中，随着实际数据的积累，查询计算和开销有可能会增加，甚至我们发现有些索引设计并不理想。令人头疼的是，线上环境根本不可能用explain去分析查询语句。这个时候，我们需要一个自动记录下运行环境中每次查询执行时间的工具 —— <strong>MySQL慢查询日志</strong>。</p>
<p>在MySQL中开启这项功能并不复杂，在my.cnf中增加下列配置选项：</p>
<pre><code>long_query_time <span class="subst">=</span> <span class="number">1</span>
<span class="keyword">log</span><span class="attribute">-slow</span><span class="attribute">-queries</span> <span class="subst">=</span> /<span class="built_in">data</span>/<span class="built_in">var</span>/mysql_slow<span class="built_in">.</span><span class="keyword">log</span>
</code></pre><p>这意味着，MySQL对执行时间超过1秒的查询请求将记录在log-slow-queries路径的文件中，我们可以用MySQL提供的mysqldumpslow查看日志，也可以通过第三方工具 —— <a href="http://www.pythian.com/blog/query-profiling-tools-part-1-mysqlsla/" target="_blank" rel="external">mysqlsla</a>。</p>
<p>当然，我们还可以在mysqlreport的友好报告中发现以下列：</p>
<pre><code>Slow 1 s           722        0.2/s         0.01     %<span class="keyword">MDS</span>: 0.08     <span class="keyword">Log</span>:<span class="keyword">ON</span>
</code></pre><p>这其实告诉我们，超过1秒的慢查询每秒有0.2次，占总请求数的0.08%。</p>
<h2 id="善其事">善其事</h2><h3 id="正确使用索引">正确使用索引</h3><p>在影响数据库查询性能的诸多因素中，索引绝对是一个重量级的因素。</p>
<h4 id="什么是索引">什么是索引</h4><p>索引说白了，就相当于一本书的目录。很容易理解，如果我们需要寻找一本书中的某一章节，我们会先去查找目录，如此做来可以大大提高查找的效率。但是如果没有索引，即书本目录，我们寻找过程就会变成全书遍历查找。</p>
<p>事实上数据库索引也是一样，可以分为<strong>全表扫描（Full Table Scan）和索引扫描（Index Scan）</strong>两种。在大多数情况下，索引搜索当然要比全表扫描性能高很多，但这也不是绝对的。比如<strong>需要查找的记录占据了整个数据表的大部分，那么使用索引扫描反而比全表扫描更差</strong>。很容易想象，对于一本书，如果需要阅读绝大部分内容，那么按顺序全局阅读比按目录查找再阅读效率更高，因为查找目录也是需要开销的。</p>
<p>另外，为数据库数据建立索引也不是一件简单的事，索引必须对应到数据库的每一行记录，这样一来，<strong>引入数据库索引将会带来一个巨大的目录</strong>，这点存储开销也是不得不重视的。而且，<strong>除了普通索引之外，还有唯一索引，主键，全文索引等，各种索引类型都有可能带来更多额外的开销，如唯一索引插入时必须保证其唯一性，而唯一性检查也是不笔不小的开销</strong>。</p>
<p>这么说来，全表扫描和索引扫描孰优孰劣真心不好说，说句真心话，这是你自己的事情。记住：<strong>为数据表建立索引是你自己的事情，永远不要期待有什么工具会自动帮你建立索引，没有工具会知道你未来会频繁地在哪个字段上进行条件查询，为哪个字段建立索引最优</strong>。</p>
<h4 id="初识索引">初识索引</h4><p>在<strong>利其器</strong>一节中，我们讨论到，可以利用<strong>explain</strong>来进行SQL语句的性能分析。我们还是接着那时的例子，利用主键id进行查询与利用普通字段name进行查询，在查询效率上确有不同，而且一般情况下(查询绝大多数条数情况除外)前者优于后者。</p>
<p>那么我们现在把name字段也修改为索引呢？利用以下语句进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="built_in">test</span> add key name(name);</span><br></pre></td></tr></table></figure>
<p>然后，我们再用<strong>explain</strong>进行查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name = <span class="string">'yoxxwmxbpvhyxtyo'</span>;</span><br></pre></td></tr></table></figure>
<p>结果稍微有点变化：</p>
<pre><code>+----+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+
|<span class="string"> id </span>|<span class="string"> select_type </span>|<span class="string"> table </span>|<span class="string"> type </span>|<span class="string"> possible_keys </span>|<span class="string"> key  </span>|<span class="string"> key_len </span>|<span class="string"> ref   </span>|<span class="string"> rows </span>|<span class="string"> Extra                    </span>|
+----+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+
|<span class="string">  1 </span>|<span class="string"> SIMPLE      </span>|<span class="string"> test  </span>|<span class="string"> ref  </span>|<span class="string"> name          </span>|<span class="string"> name </span>|<span class="string"> 257     </span>|<span class="string"> const </span>|<span class="string">    1 </span>|<span class="string"> Using where; Using index </span>|
+----+-------------+-------+------+---------------+------+---------+-------+------+--------------------------+
</code></pre><p>现在是什么情况呢？我们可以看到，这时key字段的值为name，即本次查询采用了name字段的索引。另外，<strong>对于没有使用主键索引或者唯一索引的条件查询，查询结果可能有多个匹配行，所以MySQL为这种情况定义的type为ref</strong>，如本次结果中所示。</p>
<p>那么，如果我们进行模糊查询呢？试下吧。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name like <span class="string">'%mxbpvhy'</span>;</span><br></pre></td></tr></table></figure>
<p>看下结果：</p>
<pre><code>+----+-------------+-------+-------+---------------+------+---------+------+--------+--------------------------+
|<span class="string"> id </span>|<span class="string"> select_type </span>|<span class="string"> table </span>|<span class="string"> type  </span>|<span class="string"> possible_keys </span>|<span class="string"> key  </span>|<span class="string"> key_len </span>|<span class="string"> ref  </span>|<span class="string"> rows   </span>|<span class="string"> Extra                    </span>|
+----+-------------+-------+-------+---------------+------+---------+------+--------+--------------------------+
|<span class="string">  1 </span>|<span class="string"> SIMPLE      </span>|<span class="string"> test  </span>|<span class="string"> index </span>|<span class="string"> NULL          </span>|<span class="string"> name </span>|<span class="string"> 257     </span>|<span class="string"> NULL </span>|<span class="string"> 100489 </span>|<span class="string"> Using where; Using index </span>|
+----+-------------+-------+-------+---------------+------+---------+------+--------+--------------------------+
</code></pre><p>哇，还是很强力的，连模糊查询都能够利用name索引，可以看到type字段中明确写着index值。</p>
<h4 id="使用组合索引">使用组合索引</h4><p>实际项目过程中，查询中包含组合条件是不可避免的，如：</p>
<pre><code><span class="attribute">...</span> <span class="keyword">where</span> a <span class="subst">=</span> <span class="number">1</span> <span class="literal">and</span> b <span class="subst">=</span> <span class="number">2</span>
<span class="attribute">...</span> <span class="keyword">where</span> a <span class="subst">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b
<span class="attribute">...</span> <span class="keyword">where</span> a <span class="subst">=</span> <span class="number">1</span> <span class="keyword">group</span> <span class="keyword">by</span> b
</code></pre><p>这个时候，如果a和b字段都分别建立了索引，它们仍然不能同时发挥作用。因为<strong>一次查询只能利用一个索引</strong>。如何破？组合索引大叫：我来！</p>
<p>还是基于先前的数据表，我们用以下命令删除先前增加的name索引，增加name_1和name_2两个字段，同时增加name，name_1和name_2的联合索引normal_key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table <span class="built_in">test</span> drop index name;</span><br><span class="line">alter table <span class="built_in">test</span> add name_1 not null;</span><br><span class="line">alter table <span class="built_in">test</span> add name_2 not null;</span><br><span class="line">alter table <span class="built_in">test</span> add index normal_key(name, name_1, name_2);</span><br></pre></td></tr></table></figure>
<p>至此，数据表table中，包含4个字段，具体情况如下：</p>
<pre><code>+--------+--------------+------+-----+---------+----------------+
|<span class="string"> Field  </span>|<span class="string"> Type         </span>|<span class="string"> Null </span>|<span class="string"> Key </span>|<span class="string"> Default </span>|<span class="string"> Extra          </span>|
+--------+--------------+------+-----+---------+----------------+
|<span class="string"> id     </span>|<span class="string"> int(11)      </span>|<span class="string"> NO   </span>|<span class="string"> PRI </span>|<span class="string"> NULL    </span>|<span class="string"> auto_increment </span>|
|<span class="string"> name   </span>|<span class="string"> varchar(255) </span>|<span class="string"> NO   </span>|<span class="string"> MUL </span>|<span class="string"> NULL    </span>|<span class="string">                </span>|
|<span class="string"> name_1 </span>|<span class="string"> varchar(255) </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">                </span>|
|<span class="string"> name_2 </span>|<span class="string"> varchar(255) </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">                </span>|
+--------+--------------+------+-----+---------+----------------+
</code></pre><p>而查看数据表中index得：</p>
<pre><code>+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
|<span class="string"> Table </span>|<span class="string"> Non_unique </span>|<span class="string"> Key_name   </span>|<span class="string"> Seq_in_index </span>|<span class="string"> Column_name </span>|<span class="string"> Collation </span>|<span class="string"> Cardinality </span>|<span class="string"> Sub_part </span>|<span class="string"> Packed </span>|<span class="string"> Null </span>|<span class="string"> Index_type </span>|<span class="string"> Comment </span>|<span class="string"> Index_comment </span>|
+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
|<span class="string"> test  </span>|<span class="string">          0 </span>|<span class="string"> PRIMARY    </span>|<span class="string">            1 </span>|<span class="string"> id          </span>|<span class="string"> A         </span>|<span class="string">      100288 </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|
|<span class="string"> test  </span>|<span class="string">          1 </span>|<span class="string"> normal_key </span>|<span class="string">            1 </span>|<span class="string"> name        </span>|<span class="string"> A         </span>|<span class="string">         200 </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|
|<span class="string"> test  </span>|<span class="string">          1 </span>|<span class="string"> normal_key </span>|<span class="string">            2 </span>|<span class="string"> name_1      </span>|<span class="string"> A         </span>|<span class="string">         200 </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|
|<span class="string"> test  </span>|<span class="string">          1 </span>|<span class="string"> normal_key </span>|<span class="string">            3 </span>|<span class="string"> name_2      </span>|<span class="string"> A         </span>|<span class="string">         200 </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|
+-------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</code></pre><p>可看，当前数据表的除了主键索引以外，还有我们刚设置的联合索引normal_key。</p>
<p>这个时候，我们利用<strong>explain</strong>命令看下相关查询语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name = <span class="string">'abc'</span>;</span><br><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name = <span class="string">'abc'</span> and name_1 = <span class="string">"def"</span>;</span><br><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name = <span class="string">'abc'</span> and name_1 = <span class="string">'def'</span> and name_2 = <span class="string">'ghi'</span>;</span><br></pre></td></tr></table></figure>
<p>这些查询语句的结果都是使用索引，具体结果大家可以自行尝试。</p>
<p>这里我们要引入一个<strong>“最左前缀”这个组合索引的基本原则</strong>。这个概念可以如此解释：<strong>如果查询条件检索时，只需要匹配联合索引中的最左顺序一个或多个字段，称为最左索引原则，或者叫最左前缀</strong>。所以，我们查看如下SQL语句时，得到的结果应该是不使用索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from <span class="built_in">test</span> <span class="built_in">where</span> name_2 = <span class="string">'ghi'</span> and name = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>然而实际上，还是使用索引的，不得不佩服MySQL强大的SQL优化器</strong>！</p>
<h4 id="索引的正确使用姿势">索引的正确使用姿势</h4><p>当然，事实上，<strong>在整个数据库优化过程中，索引的利用永远是难点，所以，利用好你的explain工具，千万不要想当然</strong>！</p>
<p>凡是都有两面性，所以索引的使用也会有代价产生，具体可以归纳为以下几点：</p>
<ul>
<li><strong>索引会占据更多的磁盘空间，很多时候索引甚至比数据本身还要大</strong>。不这现在磁盘的空间很容易达到TB级别，所以通常磁盘空间还未写满时，计算能力的瓶颈已经显现出来的。</li>
<li><strong>当建立索引的字段发生更新时，会引发索引本身的更新，这将产生不小的计算开销</strong>。这直接决定使用索引的数据表必须是读多写少。</li>
<li><strong>索引需要我们花费一些额外的时候来维护</strong>。MyISAM和Innodb类型的数据表存储结构会有不同，所以具体维护时也有些不同，比如MyISAM的索引写缓存由于断电可能造成索引的损坏，需要我们及时地手动修复。</li>
</ul>
<h3 id="锁写与等待">锁写与等待</h3><p>当有多个用户并发访问数据库中某一资源的时候，为了保证并发访问的一致性，数据库必须通过锁机制来协调这些访问。而<strong>锁机制也是影响数据库性能的一个重要点</strong>。</p>
<p><strong>MySQL为MyISAM类型表提供了表级别的锁定，即当有请求对数据表有更新操作（如update)时，数据表就会被锁定，其他任何对当前表的操作将被排斥，甚至包括select查询</strong>。另外需要注意的是，<strong>更新操作有着默认高优先级，即当表锁释放后，更新操作将先获得锁定，然后才能轮到读取操作</strong>。此机制将可能引发以下情况：频繁更新操作将会使得读取操作长时间等待。</p>
<p><strong>MySQL为Innodb类型表提供了行锁，即当有请求对数据表有更新操作时，数据表不是全表被锁定，而是更新的特定行，其他任何对当前行的操作将被排斥，但是对其他行的操作将不被限制</strong>。</p>
<p>从概念上对比，似乎行锁要比表锁好。但这并不是绝对的，<strong>理论上就锁定本身而言，行锁定的开销并不比表锁小</strong>。比如对于update密集型的场景，行锁定并不是救世主，因为行锁单位锁定开销比表锁大，所以具体性能只能实测。</p>
<h3 id="事务性表的性能">事务性表的性能</h3><p><strong>MySQL中Innodb类型表不仅支持行锁定，还支持事务</strong>。有时候，我们选择Innodb类型的数据表就是因为其支持事务。当然，如果我们没有在应用程序中使用事务操作的打算，而只是看中了其他特性，如行锁定，外键以及易于修复等，我们仍然可以使用它。</p>
<p>Innodb实现事务是采用<strong>预写日志方式（WAL）</strong>完成的。当有事务提交时，Innodb首先将它写到内存中的事务日志缓冲区中，随后当事务日志写入磁盘时，Innodb才更新实际数据和索引。这里，事务日志写入磁盘的时机可以分为3种：</p>
<ul>
<li>innodb_flush_log_at_trx_commit=1。这个设置表示事务提交时立即将事务写入磁盘，同时实际数据和索引也更新。</li>
<li>innodb_flush_log_at_trx_commit=0。这个设置表示事务提交时不立即将事务写入磁盘，而是每隔1秒写入磁盘文件一次，并且刷新到磁盘中，同时更新实际数据和索引。这种方式如果在事务提交和事务写入磁盘之间发生mysqld崩溃的话，那么在内存中的最近1秒的数据将会丢失，注意，是永久性丢失。</li>
<li>innodb_flush_log_at_trx_commit=2。这个设置表示事务提交时立即写入磁盘，但没有刷新到磁盘，而是存放在磁盘缓冲区，每隔1秒刷新磁盘一次，同时更新数据和索引。这种方式如果发生mysqld崩溃的话，数据并不会丢失，因为存放在磁盘缓冲区的数据还是会刷新到磁盘中。但是如果操作系统崩溃的话，那就永久丢失了。</li>
</ul>
<p>显然，第2种方式性能最高，但是丢失数据的可能性也最大。</p>
<p>另外，MySQL有一个选项会影响到上述3种方式的实现，它就是innodb_flush_method选项。我们可以将该选项设置为O_DIRECT，如下</p>
<pre><code><span class="attribute">innodb_flush_method </span>=<span class="string"> O_DIRECT</span>
</code></pre><p>如此一来，Innodb可以直接I/O，所有的读写操作将会跳过文件系统的系统缓冲区，提高I/O性能，当然，预写日志方式也就会随之改变。</p>
<h3 id="使用查询缓存">使用查询缓存</h3><p><strong>使用查询缓存的目的很简单，那就是提高数据库查询数据的性能</strong>。</p>
<p><strong>在默认情况下，MySQL是没有开启查询缓存功能</strong>的，我们可以进行以下配置进行开启（开启256MB的内存空间来缓存查询结果）：</p>
<pre><code><span class="setting">query_cache_size = <span class="value"><span class="number">268435446</span></span></span>
<span class="setting">query_cache_type = <span class="value"><span class="number">1</span></span></span>
<span class="setting">query_cache_limit = <span class="value"><span class="number">1048576</span></span></span>
</code></pre><p>查询缓存功能，不论是MyISAM还是Innodb类型，对于以select为主的应用显然性能会大增。但是令人遗憾的是，MySQL的缓存过期策略并不是十分令人满意。<strong>当一个数据表有更新操作后，那么涉及这个表的所有查询缓存均失效</strong>。话虽如此，但是对于select操作占绝大部分的应用，还是极大的福音。我们只要注意不要将其使用在select和update交叉混合的应用就可以了。</p>
<p>另外，我们可以利用mysqlreport查看查询缓存的状态，如下所示：</p>
<pre><code><span class="strong">__ Query Cache __</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>__
Memory usage   17.11k of  16.00M  %Used:   0.10
Block Fragmnt 100.00%
Hits                2     0.0/s
Inserts            13     0.0/s
Insrt:Prune      13:1     0.0/s
Hit:Insert     0.15:1
</code></pre><p>很显示，当前缓存区大小为16M，而现在使用了17K，另外，Insrt:Prume代表查询结果进入缓存的次数和过期被删除的次数的比例，当然，这个比例越大，表示查询操作与更新操作相比更频繁，也就更适合使用查询缓存。</p>
<h3 id="临时表">临时表</h3><p>我们利用mysqlreport时，可以发现有Using temporary的状态，如下：</p>
<pre><code><span class="strong">__ Created Temp __</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="emphasis">___</span>_
Disk table         75     0.0/s
Table             296     0.0/s    Size:  16.0M
File               10     0.0/s
</code></pre><p>当然，我们这里的要求就是<strong>尽量避免使用临时表，因为无论是在磁盘（Disk table），内存(Table)，还是在文件（File）中创建临时表，这都会是不小的开销</strong>。</p>
<h3 id="线程池">线程池</h3><p>与临时表类似，我们可以从mysqlreport中看到线程的使用情况：</p>
<pre><code><span class="strong">__ Threads __</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>
Running             1 of    1
Cached              1 of    8      %Hit:  97.44
Created             2     0.0/s
Slow                0       0/s
</code></pre><p>这里我们看到，线程池的命中情况为97.44%，当然，命中率100%当然是最好的。一个比较好的以夷伐夷是在应用中，<strong>尽量使用持久连接，这将在一定程度上减少线程的重复创建</strong>。</p>
<h3 id="反范式化设计">反范式化设计</h3><p>在学校的时候，数据库老师都会教我们，设计数据库的时候，要遵守一定的范式。比如说<strong>第三范式</strong>。简单的说，<strong>第三范式要求在一个数据表中，非主键字段这之间不能存在依赖关系，这样可以避免更新异常、插入异常和删除异常，保证关系的一致性，并且减少数据冗余</strong>。</p>
<p>比如以下表的设计就是遵循范式：</p>
<pre><code>（用户ID，好友ID）
（用户ID，用户昵称，用户邮箱，注册时间，联系电话）
</code></pre><p>如果这是学校考试，那绝对是满分呐。我们对这两表中的数据进行查询，比如查询某用户的其好友的昵称。这里，我们可以有两种查询方式：</p>
<ul>
<li>将两个表进行一次联合查询；</li>
<li>先在第一个表中查询出所有好友的ID，然后在第二个表中查询这些ID对应的昵称。</li>
</ul>
<p>显然，不论是采用哪一种方式，都需要打开两张数据表。那么，如果我们这么设计呢：</p>
<pre><code>（用户ID，好友ID，用户昵称）
（用户ID，用户昵称，用户邮箱，注册时间，联系电话）
</code></pre><p>这样一来，刚刚查询好友昵称的需求只需要打开第一张表就可以完成，当然付出的代价就是数据有冗余，而且进行数据更新时，可能会对数据造成不一致。但是实际中，有多少用户会一直修改它的昵称呢？所以，<strong>实际中，引入一些反范式的设计也是可行的，当然前提是，它的性能将会提高</strong>。</p>
<h3 id="放弃关系型数据库">放弃关系型数据库</h3><p>有些时候，相较于传统关系型数据库，我们采用Key-Value形式的数据库更加简单有效。具体可以阅读下相关资料 —— <a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/01/30//2015/01-30-0.html/" itemprop="url">
                构建高性能服务器 -- 负载均衡篇
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-01-30T00:00:00+08:00" content="1月 30 2015">
            1月 30 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/服务器编程/" itemprop="url" rel="index"><span itemprop="name">服务器编程</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="说在前面的话">说在前面的话</h2><p>服务器规模的扩展是构建高性能服务器过程中不得不面对的事。当然，这里我们不是指<strong>垂直扩展</strong>，即增加服务器的硬件性能，如CPU频率，内存等，从而提升服务器单机处理能力，而是<strong>水平扩展</strong>，即增加服务器台数，而每台服务器的单机处理能力可能并不出众。</p>
<p>那么，问题来了，这么多的机器，也可以称为服务器节点，该如何选择由哪个节点处理呢？会不会出现请求总是发向固定一个或者几个节点，从而造成这些节点负载高，请求来不及处理，同时剩余的节点又非常空闲呢？当然，这个时候<strong>负载均衡</strong>技术就该大显身手了。</p>
<h2 id="HTTP重定向">HTTP重定向</h2><p>Http重定向可以将HTTP请求进行转移，它在Web开发中十分常见，比如用户登陆成功后自动跳转到相应的管理页面。然而事实上它也可以用来做负载均衡。</p>
<p>我们熟悉的镜像下载事实上就是HTTP重定向进行负载均衡的最鲜活生动的例子。我们以从<a href="github.com">github</a>下载一个zip包为例。在你的终端中输入以下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/mogutt/TTServer/archive/master.zip</span><br></pre></td></tr></table></figure>
<p>以上命令就是获取github上某一下载包，其过程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--2015-01-25 14:05:20--  https://github.com/mogutt/TTServer/archive/master.zip&#10;Resolving github.com (github.com)... 192.30.252.130&#10;Connecting to github.com (github.com)|192.30.252.130|:443... connected.&#10;HTTP request sent, awaiting response... 302 Found&#10;Location: https://codeload.github.com/mogutt/TTServer/zip/master [following]&#10;--2015-01-25 14:05:22--  https://codeload.github.com/mogutt/TTServer/zip/master&#10;Resolving codeload.github.com (codeload.github.com)... 192.30.252.147&#10;Connecting to codeload.github.com (codeload.github.com)|192.30.252.147|:443... connected.&#10;HTTP request sent, awaiting response... 200 OK&#10;Length: 501048 (489K) [application/zip]&#10;Saving to: &#8216;master.zip&#8217;&#10;100%[==================================================================&#62;] 501,048     45.4KB/s   in 12s&#10;2015-01-25 14:05:35 (40.9 KB/s) - &#8216;master.zip&#8217; saved [501048/501048]</span><br></pre></td></tr></table></figure>
<p>分析以上过程，我们发现，<em>wget</em>命令首先向<em>github.com</em>（192.30.252.130）发送一个http请求，但是收到的状态码为302，而<strong>302状态码就是让<em>front end</em>重新发送请求至另外新的url上，在字段Location上标志，这里即<em>codeload.github.com</em>域名下</strong>。这里有同学就会有疑问：哪里有负载均衡的影子？莫急，且听我慢慢道来。请注意这里重定向的做法，我们本来请求的是域名A，即<em>github.con</em>，但是服务却响应状态码302，让我们重新将请求发至域名B，即<em>codeload.github.com</em>。既然Http重定向可以将请求重新转发至另外的服务器，那么用来做负载均衡有何不可？我们可以总是将Http请求重新定向到负载较小的服务器，如此一来，负载均衡的目的就达到了。</p>
<p>但是，现实总是残酷的。Http重定向实现负载均衡虽然简单易行，但是我们发现，每次请求都会客户端向服务器发送请求， 然后服务器响应Http重定向，然后客户端用新得到的服务器地址再一次请求，最后服务器发送正确响应。OMG，一个请求在客户端与服务端之间来回跑了两次！这是多大的消耗啊！所以<strong>若是对性能有高要求，Http重定向实现负载均衡终归不是较优选择</strong>。</p>
<h2 id="DNS负载均衡">DNS负载均衡</h2><p>我们知道，DNS负责提供域名解析服务，即将域名解析成实际服务器的IP地址。那么，我们能让DNS稍微智能点，在其解析成实际服务器地址时，帮我们进行负载均衡呢？当然，这里的答案的肯定的。</p>
<p>首先，我们来看一个<em>www.google.com</em>在小猿所在地杭州西湖会解析成什么IP地址。在终端下输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.google.com</span><br></pre></td></tr></table></figure>
<p>得到如下结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.9</span>.<span class="number">5</span>-<span class="number">4.3</span>-Ubuntu &lt;&lt;&gt;&gt; www.google.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">12748</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">5</span>, AUTHORITY: <span class="number">0</span>, ADDITIONAL: <span class="number">1</span></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, flags:; udp: <span class="number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.google.com.                        IN      A</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.google.com.         <span class="number">30</span>      IN      A       <span class="number">173.194</span>.<span class="number">127.210</span></span><br><span class="line">www.google.com.         <span class="number">30</span>      IN      A       <span class="number">173.194</span>.<span class="number">127.211</span></span><br><span class="line">www.google.com.         <span class="number">30</span>      IN      A       <span class="number">173.194</span>.<span class="number">127.208</span></span><br><span class="line">www.google.com.         <span class="number">30</span>      IN      A       <span class="number">173.194</span>.<span class="number">127.209</span></span><br><span class="line">www.google.com.         <span class="number">30</span>      IN      A       <span class="number">173.194</span>.<span class="number">127.212</span></span><br><span class="line">;; Query time: <span class="number">71</span> msec</span><br><span class="line">;; SERVER: <span class="number">127.0</span>.<span class="number">1.1</span><span class="comment">#53(127.0.1.1)</span></span><br><span class="line">;; WHEN: Sun Jan <span class="number">25</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">34</span> CST <span class="number">2015</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<p>这里，我们可以看到，<em>www.google.com</em>拥有5个不同的A记录，事实上DNS解析域名时，也是轮流解析成不同IP地址，以实现简单的负载均衡。</p>
<p>但是，DNS实现负载均衡有一个巨大的弊端，即DNS会进行缓存。DNS缓存本身是一件好事，它会缓解DNS服务器的压力，并且达到快速解析URL的作用。但是若是采用DNS缓存进行负载均衡，其缓存功能就会带来一定的问题：若其中一台服务器出现故障，将其在DNS解析规则中移除，向它的更新要经过TTL时间（一般会设置为10分钟）才会对用户生效，这将是灾难型的。</p>
<p>另一方面，由于DNS负载均衡调度器基本DNS层面，这将导致它的调度灵活性大大减少，比如无法在应用层面（根据HTTP请求的内容）对客户端请求进行策略调度，又或者无法根据服务器真实的负载情况进行灵活调度，将请求转发至负载较小的服务器。</p>
<p>总之，<strong>DNS负载均衡技术看似美好，但是由于它的缓存机制和基本DNS层的特性，最终将其推向无法实际应用的深渊</strong>。</p>
<h2 id="反向代理负载均衡">反向代理负载均衡</h2><p><a href="http://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="external">反向代理</a>大家都不陌生，但是它的功能不仅仅如此，事实上，它还能完成负载均衡的工作。<strong>目前几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡</strong>。</p>
<p>相比于之前介绍的Http重定向负载均衡和DNS负载均衡，反射代理负载均衡更注重的是请求的“转发”，而前两者更偏向于“转移”。当然，无论是“转发”还是“转移”，我们最终的目的还是相同的，即实现服务器的负载均衡。</p>
<p>那么，反向代理实现负载均衡有什么优势呢？通过我们之前的分析，<strong>Http重定向会让请求在广域网上来回多跑一次，耗时巨大，而DNS实现负载均衡又无法根据实际服务器的真实负载进行均衡，缺乏灵活性</strong>。而反射代理负载均衡将这两个问题全部解决。</p>
<p>但是，反射代理负载均衡也有它的缺点。由于我们是通过反射代理这种机制，即通过Web服务器进行Http请求的调度，这就意味着两件事：</p>
<ul>
<li>任何对于实际服务器的HTTP请求都必须经过调度器；</li>
<li>调度器必须等待实际服务器的HTTP响应，并将它反馈给用户。</li>
</ul>
<p>而这两件事就决定着所有实际服务器的HTTP流量都要经过调度器，即Web服务器。所以，<strong>若采用这种负载均衡方案，如果后期实际服务器压力巨大需要扩容时，就会有一个制约，那就是Web服务器将成为整个系统的瓶颈</strong>。比如服务器不是密集计算型，则扩展实际服务器对整体的吞吐率提升没有多大的帮助，因为大量的压力在反向代理服务器上。当然，我们了解了这点，只要扩展反向代理服务器就行了。但是<strong>我们将不得不面对服务器可能产生的实际服务器压力或者反向代理服务器压力</strong>。</p>
<h2 id="IP负载均衡">IP负载均衡</h2><p>之前讲述利用反向代理服务器实现负载均衡时，我们没有提到，这种<strong>负载均衡方案是基于HTTP层面的，即应用层</strong>。我们知道，应用层是网络分层模型中属于最上层，所以每次HTTP请求转发时，都要经过数据链路层（第二层）、网络层（第三层）、传输层（第四层）的转换，实际上这些性能开销是可以尽量避免的。首先，我们来看看传输层上有没有相应的负载均衡方案。</p>
<p>还记得<a href="http://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="external">网络地址转换（NAT）</a>技术吧。当然，这个过程还是一样的。</p>
<p><img src="/img/2015-01-30-0.jpg" alt=""></p>
<p>如上图所示，NAT服务器有两块网卡（可能虚拟出来），分别连接外部网络与内部网络，连接外部网络的IP地址为125.12.12.12，连接内部网络的IP地址为10.0.1.50。在内网中与NAT服务器相连的是两台实际服务器，IP地址分别为10.0.1.210和10.0.1.211，它们的默认网关均为10.0.1.50，同时它们在8000端口上监听服务。我们假设从外部IP为202.20.20.20:5656发送数据包至服务器地址125.12.12.12:80。这时，数据包的源IP地址与目的IP地址分别如下：</p>
<pre><code>来源<span class="tag">IP</span>地址: 202<span class="class">.20</span><span class="class">.20</span><span class="class">.20</span><span class="pseudo">:5656</span>
目的<span class="tag">IP</span>地址： 125<span class="class">.12</span><span class="class">.12</span><span class="class">.12</span><span class="pseudo">:80</span>
</code></pre><p>当数据包到达NAT服务器时内核缓冲区后，NAT服务修改其数据包的目的IP地址，将其修改为实际服务器IP地址，假设修改为10.0.1.210:8000，则经过NAT服务器后，数据包的源IP地址与目的地址分别如下：</p>
<pre><code>来源<span class="tag">IP</span>地址: 202<span class="class">.20</span><span class="class">.20</span><span class="class">.20</span><span class="pseudo">:5656</span>
目的<span class="tag">IP</span>地址： 10<span class="class">.0</span><span class="class">.1</span><span class="class">.210</span><span class="pseudo">:8000</span>
</code></pre><p>当然，这个数据包最终会到达10.0.1.210这台实际服务器，经过处理后，实际服务器返回响应数据包，其源IP地址与目的地址分别如下：</p>
<pre><code>来源<span class="tag">IP</span>地址: 10<span class="class">.0</span><span class="class">.1</span><span class="class">.210</span><span class="pseudo">:8000</span>
目的<span class="tag">IP</span>地址：202<span class="class">.20</span><span class="class">.20</span><span class="class">.20</span><span class="pseudo">:5656</span>
</code></pre><p>由于实际服务器的网关为10.0.1.50，所以数据包会到达NAT服务器，而数据包在NAT服务器的内核缓冲区中，其来源IP地址又会被修改为NAT服务器的IP地址，即125.12.12.12，这时其源IP地址与目的地址分别如下：</p>
<pre><code>来源<span class="tag">IP</span>地址: 125<span class="class">.12</span><span class="class">.12</span><span class="class">.12</span><span class="pseudo">:80</span> 
目的<span class="tag">IP</span>地址： 202<span class="class">.20</span><span class="class">.20</span><span class="class">.20</span><span class="pseudo">:5656</span>
</code></pre><p>所以，在客户端角度看来，他完全不知道有NAT服务器与实际服务器的存在，所以利用NAT服务器进行负载均衡是完全可行的，而且过程就如上述描述过程。</p>
<p>那么问题就剩下这个NAT服务器如何实现了。往简单了说，就是如何修改IP数据包。事实上，Linux内核已经具备这样的能力，从Linux2.4内核开始，其内置的<a href="http://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="external">Netfilter</a>模块就可以实现这样的功能。通过<a href="http://en.wikipedia.org/wiki/Iptables" target="_blank" rel="external">iptables</a>就可以控制Netfilter模块进行IP数据包的修改。</p>
<p>不严谨的说，NAT服务器就如同路由器一样，它连接外部网络和私有网络，并将来自外部网络的数据包正确转发至私有网络机器。当然，实际上这不能称为路由器。<strong>我们知道路由器的工作是存储转发，除了修改数据包的MAC地址以外，通常它不会对数据包做其他手脚，但这里的NAT服务器却是要对数据包进行必要的修改，包括来源地址和端口，或者目的地址和端口</strong>。</p>
<p>但是，与反向代理一样，NAT服务器<strong>不仅要将用户的请求转发给实际服务器，同时还要将来自实际服务器的响应转发给用户，所以实际上在数据流量较大时，NAT服务器也将成为瓶颈</strong>。请不要忘记，<strong>NAT服务器的数据包转发是在内核缓存中实现的，所以其开销与应用层转发相比将会小很多，所以NAT服务器的转发能力主要取决于NAT服务器的网络带宽，当然同时包括外部网络和内部网络</strong>。</p>
<p>BWT，由于利用NAT实现负载均衡由于工作在运输层，所以还有一个附加的优点：<strong>除了支持HTTP协议以下，还支持其他网络服务协议，如FTP，SMTP，DNS等</strong>。</p>
<h2 id="直接路由">直接路由</h2><p>之前讲述的是基于运输层的负载均衡实现，现在我们来看下基于数据链路层的实现。简单来说，它就是<strong>修改数据包的目标MAC地址，将数据包转发到实际服务器上，并且最重要的是，实际服务器的响应包将直接发送至客户端，而不经过调度器</strong>。</p>
<p>R U kidding me？这不可能吧，不经过调度器直接将响应数据包发送至客户端，那不是要求<strong>实际服务器要接入外部网络</strong>？当然，这点是肯定的。</p>
<h3 id="IP别名">IP别名</h3><p>首先，我们来了解一下IP别名。我们知道，一个网络接口拥有一个IP地址，但是除此之外，我们还可以为它配置多个IP地址，它们称为<strong>IP别名</strong>。这里的<strong>网络接口可以是物理网卡，如eth0，eth1，也可以是虚拟接口，如回环网络接口lo</strong>。</p>
<p>配置IP别名的方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0:<span class="number">0</span> <span class="number">192.168</span>.<span class="number">0.200</span></span><br></pre></td></tr></table></figure>
<p>上述命令将给本机增加一个IP别名，具体为<em>192.168.0.200</em>。这时我们通过<em>ping</em>命令可以直接通过IP别名连接到本机，当然，在局域网其他机器上用<em>arp</em>命令也可以看到刚新加的IP别名，而且应该与其他另外一个IP拥有相同的MAC地址，而另外一个IP就是本机原来的IP地址。这时，我们就有两个IP指向了同一个MAC地址，即两个IP指向了同一个机器。</p>
<h3 id="修改MAC地址进行负载均衡">修改MAC地址进行负载均衡</h3><p>之前我们也讨论过，将数据包的目标MAC地址修改成实际服务器的MAC地址，那么该数据包将会转发给实际服务器。同时，实际服务器又直接接入外部网络，所以实际服务器的响应包不经过调度服务器就可以直接发送回客户端。那么设置IP别名有什么作用呢？事实上，这种方法因为只操作在数据链路层，所以只修改了数据包的目的MAC地址，而网络层相关的数据，如IP地址和端口，还是保持原样的。所以当实际服务器收到数据包时，它会发现该数据包的IP地址并不是它自己的IP地址，这时会发生什么事呢？当然，这种事谁也不想发生。所以这个时候，IP别名就起到了关键性作用，将IP别名设置成与调度服务器的IP相同，这样实际服务器收到的IP包将会非常有归属感。</p>
<p>我们还是看下示意图：</p>
<p><img src="/img/2015-01-30-1.jpg" alt=""></p>
<p>具体各服务器的IP地址，网关，IP别名如下表所示：</p>
<table>
<thead>
<tr>
<th>服务器说明</th>
<th>外部网络IP地址</th>
<th>默认网关</th>
<th>IP别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>负载均衡调度器</td>
<td>125.12.12.12</td>
<td>125.12.12.1</td>
<td>125.12.12.77</td>
</tr>
<tr>
<td>实际服务器</td>
<td>125.12.12.20</td>
<td>125.12.12.1</td>
<td>125.12.12.77</td>
</tr>
<tr>
<td>实际服务器</td>
<td>125.12.12.21</td>
<td>125.12.12.1</td>
<td>125.12.12.77</td>
</tr>
</tbody>
</table>
<p>我们看到，两台实际服务器都具有外网IP地址，即接入外部网络，同时均设置了IP别名为125.12.12.77。但是该IP地址并不是负载均衡调度器的IP地址，而负载均衡调度器同时也设置IP别名为125.12.12.77。这是出于什么考虑呢？这样做当然拥有其优点，这样负载均衡调度器可以方便进行替换，只要新设置的负载均衡调度器设置成与实际服务器相同的IP别名即可。    </p>
<p>当客户端数据包来临时，当然该数据包发向的IP地址为125.12.12.77，即负载均衡调度器可以收到该数据包。这里有同学就会有疑问，实际服务器与调度服务器拥有相同的IP别名，而且均接入外网，为什么不是实际服务器收到数据包呢？事实上，网关在收到数据包时，通过<em>arp</em>会问：你们谁的IP地址是125.12.12.77？这个时候，只要调度服务器回答：我！而实际服务器不作声就可以了。当然这里就不详细介绍怎么设置，有兴趣的同学可以搜索关键字“防止服务器响应ARP广播”即可。</p>
<p>调度服务器通过某些策略，如<a href="http://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank" rel="external">RR(Round-robin)</a>，然后将数据包转发给后端实际服务器，假设这里转发给IP地址为125.12.12.20这台实际服务器（通过修改目标MAC地址）。该服务器收到数据包后，发现该数据包的目的IP地址正是自己的IP别名，因为就快乐的收下了。当其处理完业务逻辑，准备给客户端响应时，响应数据包绕过调度服务器，直接发送至125.12.12.1的网关，从而送向外网，到达客户端。</p>
<p>整个过程非常流畅，<strong>实际服务器收到的数据包经过调度服务器负载均衡的，而发送的响应数据包直接流向外网，绕过调度服务器</strong>。如此一来，<strong>上节中NAT负载均衡方法的弱点 — 请求与响应均经过调度服务器，将毫不存在</strong>。</p>
<p>可惜的是，通过直接路由进行负载均衡也有其不优美之处。<strong>首先，使用直接路由进行数据包转发是基于数据链路层的，因此无法修改数据包的目的端口。其次，由于实际服务器必须连接外网，因此要向IDC购买合法IP地址，不过相比于负载均衡硬件设备，它们还是要便宜得多</strong>。</p>
<h2 id="IP隧道">IP隧道</h2><p>前文讲述的<strong>直接路由负载均衡方法，实际服务器和调度服务器必须在同一个网段，而本节讲述的IP隧道负载均衡方法可以跨WAN网段进行负载均衡</strong>。</p>
<p>基于IP隧道的数据包转发机制，往简单了说，就是<strong>将调度器收到的IP数据包重新封装成一个新的IP数据包，然后将新的数据包转发给实际服务器，然后实际服务器将响应直接发送给客户端</strong>。当然，大家都注意到了，利用此法进行负载均衡，<strong>实际服务器也必须接入外网</strong>，因为与直接路由方法相似，响应数据包要直接从实际服务器发送到客户端，而不经过调度服务器。</p>
<p>另外，<strong>基于IP隧道的负载均衡方式，由于可以跨WAN网段进行数据包转发，所以我们可以将实际服务器根据需要部属在不同的地域，并且根据就近访问的原则来转移请求，比如一些CDN服务便是基于IP隧道技术来实现的</strong>。</p>
<h2 id="写在最后">写在最后</h2><p>总的来说，各种负载均衡技术可归纳为：</p>
<ul>
<li><strong>基于HTTP重定向负载均衡性能上不佳；</strong></li>
<li><strong>基于DNS负载均衡灵活性不够；</strong></li>
<li><strong>基于反向代理负载均衡在应用层操作，可以根据应用层数据进行数据转发，但性能上相较于更低层负载均衡较差；</strong></li>
<li><strong>基于IP负载均衡请求响应均经过调度服务器，后期服务器扩展上，调度服务器将成为瓶颈；</strong></li>
<li><strong>基于直接路由和基于IP隧道的负载均衡技术都适合请求和响应不对称的服务器，如视频服务器，文件下载服务器等，可以非常有效地提高集群的扩展能力；</strong></li>
<li><strong>实际实现过程中，还是要与业务紧密结合的，比如CDN服务需要将实际服务器部署在不同的IDC，所以只能采用基于IP隧道的方法。</strong></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/01/25//2015/01-25-0.html/" itemprop="url">
                移动时代互联网金融的架构趋势
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-01-25T00:00:00+08:00" content="1月 25 2015">
            1月 25 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/服务器编程/" itemprop="url" rel="index"><span itemprop="name">服务器编程</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="引子">引子</h2><p>有幸参加了<a href="https://www.upyun.com/index.html" target="_blank" rel="external">又拍网</a>组织的Open Talk No.2 — 移动时代互联网金融的架构趋势。虽然没有接触过互联网金融这方面的内容，但是怀着成为一个合格程序员的人生梦想的人，怎能错过这样的聚会。</p>
<p>本次Talk请来了三位讲师分别讲述了其所在公司的相关后台技术架构，技术虽然各有千秋，但万变不离其中：<strong>并发，缓存，异步是后台永恒的话题</strong>。</p>
<p>下面主要回顾下挖财和同盾科技的两位讲师的Key Point，而51信用卡的分享以其原始PPT呈现。</p>
<h2 id="挖财的互联网金融技术探索">挖财的互联网金融技术探索</h2><p>讲师是挖财首席架构师王福强，原阿里资深架构师。他的主题分为以下：</p>
<ul>
<li><p><strong>Separation Everywhere</strong>，即组件分离，将服务分组，模块化，有点类似<a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="external">SOA</a>的味道（事实上就是SOA）。模块化架构不仅易于后期的代码重构，而且也方便后期的架构调整。而且，组件分离后，可以对各类服务进行分组，将耗时操作与非耗时操作分离，保证两者互不干涉，即使一方繁忙时也不影响另一方。</p>
</li>
<li><p><strong>Async Everywhere</strong>，即异步化。服务器并发量达到一定数量级，必需经过调用的异步化。当相对耗时调用等待时，可以进行其他调用的处理，以此让服务器并发化处理相应业务。</p>
</li>
<li><p><strong>Message Passing Everywhere</strong>，即消息化。服务器内部或者之间通信全部使用消息机制，统一调度。这里<a href="http://baike.baidu.com/view/3118541.htm" target="_blank" rel="external">消息中间件</a>就会大显身手。这里挖财就应用了<a href="http://kafka.apache.org/" target="_blank" rel="external">Kafka</a>。</p>
</li>
<li><p><strong>Immutability Everywhere</strong>，即持久化。内存中的数据在断电后是无法恢复的，所以一些重要数据，特别是互联网金融领域的相关数据，是不能丢失的，所以及时对数据进行持久化是十分必要的。</p>
</li>
<li><p><strong>Security Everywhere</strong>，即安全性。与持久化类似，互联网金融领域的一些数据是用户的敏感数据，所以对数据的安全必须要仔细考虑。如果数据被拖库的话，在业内声誉就基本毁于一旦了。</p>
</li>
<li><p><strong>Intercept Everywhere</strong>，即拦截。与安全性一样，对敏感业务，数据必须要多长一个心眼。</p>
</li>
<li><p><strong>Auditing Everywhere</strong>，即监控化。服务器硬件各项指标，如CPU负载，内存利用率，磁盘利用率，网络I/O状态等，服务器业务进程各项指标，如业务请求成功数，失败数等，都必须收集汇总，以显示服务器健康度。</p>
</li>
<li><p><strong>Bulkheads Everywhere</strong>，即隔离化。同样这也是服务器架构方面的注意点，合理分层化，模块化，某一服务的异常确保不会影响到其他服务。</p>
</li>
<li><p><strong>Switches Everywhere</strong>，即开关化。针对单独业务接口，或者单独用户，又或者单独IP进行服务开关化。在遇见异常情况下，如恶意用户进行的攻击，窃取私密数据时，及时关闭相应服务。</p>
</li>
<li><p><strong>Redundancy Everywhere</strong>，即冗余化。特别是金融重要数据，如果其丢失将造成不可挽回的损失，所以对相应数据的冗余化，及时做备份也是必要的。</p>
</li>
<li><p><strong>Reactive Everywhere</strong>，即事件驱动化（可能并不是很准确）。这里是指采用事件驱动，网络请求，信号发生等采用事件循环驱动，可以高性能进行并发服务处理。比如<a href="http://libevent.org" target="_blank" rel="external">libevent</a>、<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="external">libev</a>、<a href="https://github.com/libuv/libuv" target="_blank" rel="external">libuv</a>就是成熟的事件驱动框架。</p>
</li>
</ul>
<h2 id="从零打造千万级的实时风控云服务">从零打造千万级的实时风控云服务</h2><p>讲师是来自同盾科技的联合创始人、技术总监张新波，原阿里集团安全部专家。</p>
<h3 id="挑战">挑战</h3><p>风控云服务如果要做好，就必需跨越以下几个挑战：</p>
<ul>
<li><strong>性能</strong></li>
<li><strong>可用性</strong></li>
<li><strong>可扩展性</strong></li>
</ul>
<p>事实上，所有后台服务器如果要支持大并发量都要考虑以上3点挑战。</p>
<p>具体到风控云服务上（具体点就是同盾科技内部），性能上的挑战有：</p>
<ul>
<li>实时性要求高，服务响应时间通常小于500ms（客户要求）</li>
<li>计算结果无法缓存，全部需要实时动态计算（风控业务要求)</li>
<li>参与计算数据量大，计算维度多且复杂（风控业务要求）</li>
<li>无法像静态资源盘多机房缓存和加速（风控业务要求）</li>
</ul>
<p>而可用性上有：</p>
<ul>
<li>保证服务的稳定性，消除单点故障（服务器基本要求）</li>
<li>完备的灾备和紧急处理方案，以备不时之需（服务器基本要求）</li>
</ul>
<p>在可扩展性上则为：</p>
<ul>
<li>应用服务器可线性扩展，支撑业务的快速发展（服务器基本要求）</li>
<li>海量数据的存储和计算，支持线性扩展（服务器基本要求）</li>
</ul>
<p>可见，在可用性和可扩展性上，同盾科技的实时风控云服务与一般高性能服务器挑战一致，但是在性能上却更具有挑战性，由于一些业务上的特殊情况，不能缓存计算结果将会对服务器的情况上造成巨大的伤害。</p>
<h3 id="服务器架构演化">服务器架构演化</h3><p>下图是同盾科技最早版本的服务器架构V0.1（切莫嘲笑其简单，创业初期先走业务实现是根本原则）：<br><img src="/img/2015-01-25-0.jpg" alt=""></p>
<p>我们可以看到，整套服务器采用<a href="http://httpd.apache.org/" target="_blank" rel="external">Apache</a>作为服务器的接入层，具体业务逻辑层分别用两台机器做为Admin控制和具体接口服务逻辑计算，而数据层则直接用<a href="http://www.mysql.com/" target="_blank" rel="external">MySQL</a>进行存储。特别注意，业务主要逻辑(用户校验，查找策略，保存数据)采用的是直接向数据库<strong>同步</strong>加载数据，而我们知道数据库操作的慢速操作，因此整个服务的并发上不去，明显这个操作将会成为巨大的瓶颈。</p>
<p>因此，在V0.2时，针对V0.1中的同步向数据库读取数据的操作进行缓存优化，使用<a href="https://code.google.com/p/guava-libraries/wiki/CachesExplained" target="_blank" rel="external">Guava Cache</a>定时预先加载，缓存全部用户及对应的策略数据。当然这里有些同学就有疑问了，缓存全部用户数据这是不是脑洞太大了。没错，就是全部用户数据，由于早期用户数据不多且业务类型特性（面向企业）决定全部数据也不是不可控。<br>在另一方面，数据库写入操作则采用异步写入，引入<a href="http://en.wikipedia.org/wiki/Berkeley_DB" target="_blank" rel="external">Berkeley DB</a>作为本地队列辅助进行异步写入。</p>
<p>在V0.2中，随着用户数据量的增多，原先使用Guava Cache进行缓存的方式已经力不从心，所以在V0.3中直接用<a href="http://memcached.org/" target="_blank" rel="external">Memcached</a>代替，而且对缓存数据进行了Base64+Gzip的压缩，减少缓存的数据大小。当然，有同学有疑问进行数据压缩转换是否增加了性能压力。事实上，这点性能的损失对服务整体的耗时来说可以忽略不计，所以引入压缩转换减少的缓存量和网络传输量在性价比上来说是值得的。</p>
<p>我们注意到，在上面提及的所有版本中都没有集群的概念，事实上，所有的服务都是单点。当然，这对于一个服务的可用性来说是不良信号，所以在V1.0版本时，不仅消除单点问题，而且新增监控系统(<a href="http://www.zabbix.com/" target="_blank" rel="external">Zabbix</a>)，同时，接入层由Apache替换成性能更强力的<a href="http://nginx.com/" target="_blank" rel="external">Nginx</a>，具体架构如下：<br><img src="/img/2015-01-25-1.jpg" alt=""></p>
<p>但是这样就够了吗？</p>
<p>业务数据增加过快，直接引入了新的问题：数据库分表已无法解决数据增加过快问题。所以在V2.x中引入<a href="http://cassandra.apache.org/" target="_blank" rel="external">Cassandra</a>数据库，其Wide column store的特点正好解决数据单表过大无法存储的问题。同时，为了解决根据任意维度进行数据查询和分析的性能问题，引入<a href="http://www.elasticsearch.org/" target="_blank" rel="external">ElasticSerch</a>进行全字段索引查询。另一方面，坐拥大数据却不知利用则会冠以暴殄天物之名。所以引入<a href="https://spark.apache.org/" target="_blank" rel="external">Spark</a>进行离线分析，<a href="https://spark.apache.org/streaming/" target="_blank" rel="external">Spark streaming</a>结合<a href="https://spark.apache.org/streaming/" target="_blank" rel="external">Kafka</a>则进行实时流计算，<br>所以现在的架构演化成如下：<br><img src="/img/2015-01-25-2.jpg" alt=""></p>
<h3 id="架构演化带来的思考">架构演化带来的思考</h3><ul>
<li><strong>使用熟悉、成熟和社区活跃的开源技术</strong>。</li>
<li><strong>先满足业务需求，再优化，逐步演进</strong>。</li>
<li><strong>监控报警，应急预案必须成为系统的一部分</strong>。</li>
<li><strong>纸上得来终觉浅，绝知此事要躬行</strong>。</li>
</ul>
<h2 id="51信用卡的日志分析变迁史">51信用卡的日志分析变迁史</h2><p>参见文后Reference。</p>
<h2 id="[Reference]">[Reference]</h2><ul>
<li><a href="http://upyun-open-talk.b0.upaiyun.com/wacai.pdf" target="_blank" rel="external">挖财的互联网金融技术探索</a></li>
<li><a href="http://upyun-open-talk.b0.upaiyun.com/tongdun.pdf" target="_blank" rel="external">从零打造千万级的实时风控云服务</a></li>
<li><a href="http://upyun-open-talk.b0.upaiyun.com/51xinyongka.pdf" target="_blank" rel="external">51信用卡的日志分析变迁史</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/01/23//2015/01-23-0.html/" itemprop="url">
                构建高性能服务器 -- 缓存篇
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-01-23T00:00:00+08:00" content="1月 23 2015">
            1月 23 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/服务器编程/" itemprop="url" rel="index"><span itemprop="name">服务器编程</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="引子">引子</h2><p>说到缓存，相信大家都不陌生。<strong>缓存的目的都在于避免重复的慢速计算，比如数据库访问</strong>。相对于慢速计算，缓存将会大大提高数据存取的速率，当然同时将会缩短用户每次请求处理的时间，从而提升服务器单位时间内的请求处理数，即吞吐率。</p>
<h2 id="操作系统中的缓存">操作系统中的缓存</h2><p>事实上，我们使用的操作系统中都存在着大量的缓存机制，比如文件系统存在<strong>内核缓冲区</strong>。它位于物理内存的内核地址空间，除了使用<strong>O_DIRECT</strong>标记打开的文件以外，所有对磁盘文件的读写操作都要经过它，所以它相当于磁盘的缓存区域。</p>
<p>这块内核缓冲区也称为<strong>页高速缓存</strong>，实际上它包括以下两部分组成：</p>
<ul>
<li>读缓存区</li>
<li>写缓存区</li>
</ul>
<p>读缓存区保存着最近从磁盘上读取的数据，当下次读取相同数据时，可以直接从读缓存区直接读取数据，避免了从磁盘上进行慢速操作。</p>
<p>写缓存区则保存着将要写入磁盘的数据，从而避免用户进程直接进行磁盘数据的写入而产生慢速操作等待。</p>
<p>所以无论是读缓存区还是写缓存区，都有效避免用户进程直接进行慢速操作，即直接与磁盘进行数据交互 —— 读或者写。</p>
<h2 id="服务器中的缓存">服务器中的缓存</h2><p>与操作系统中的缓存类似，我们构建高性能服务器时，也可以<strong>在服务器的业务逻辑层与数据层（数据一般存入数据库进行持久化）之间再加设一层缓存层</strong>。当然，缓存层的作用也就是避免业务逻辑层与数据层直接交互，从而产生慢速操作，进而影响到服务器的性能。</p>
<p>当业务逻辑层需要读取数据层的相关数据时，向缓存层请求相应数据，若数据存在于缓存层，则直接从缓存层读取，若不存在，则向后端数据层读取，并同时向缓存层保存一份。当下次请求相同数据时，则无需向数据层请求，因为缓存层中已有相应数据。</p>
<p>当业务逻辑层需要向数据层写入数据时，首先向缓存层请求数据写入，并快速响应写入成功，而缓存层再异步向数据层真正写入数据。如此做法可以减少用户请求等待时间，提高服务器并发性能。</p>
<h2 id="分步式缓存系统">分步式缓存系统</h2><p>开源社区已有非常成熟的分布式缓存系统，比如说<a href="http://memcached.org/" target="_blank" rel="external">memcached</a>, <a href="http://redis.io/" target="_blank" rel="external">redis</a>等。它们都是属于<a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a>范畴，都是以Key-Value形式进行存储的。</p>
<p>我们以memcached为例。</p>
<p>首先，memcached高效的最大原因就是其<strong>基于Key的Hash算法来存储数据结构，并且使用了非常高效的内存分配器（事先向操作系统请求了大片内存，再进行自我管理，避免大量内存申请与释放操作）</strong>，所以使数据项的查询时间复杂度达到O(1)。</p>
<p>其次，<strong>memcached采用<a href="http://libevent.org/" target="_blank" rel="external">libevent</a>作为其底层的网络事件库</strong>。而libevent又是业界较好的同类型开源库，所以从底层I/O网络模型上保障其可以进行高并发数据存取操作。</p>
<p>再次，memcached是一种分步式缓存系统，所以<strong>在理论上可以无限扩容，即扩展服务器数量，提高服务器集群并发处理能力</strong>。而且，它采用<strong><a href="http://zh.wikipedia.org/zh/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C" target="_blank" rel="external">一致性Hash</a></strong>方法，从而减少因缓存服务器扩容或者下线造成的数据缓存失效问题。</p>
<p>BTW，memcached采用<strong>LRU(Least Recently Used)</strong>及时淘汰非热点数据，从而保障所缓存数据均为热点数据，最大效率使用机器内存。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/01/22//2015/01-22-0.html/" itemprop="url">
                构建高性能服务器 -- 指标篇
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-01-22T00:00:00+08:00" content="1月 22 2015">
            1月 22 2015
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/服务器编程/" itemprop="url" rel="index"><span itemprop="name">服务器编程</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="理想与现实">理想与现实</h1><p>人们总是希望花最少的钱，办最多的事。对于服务器的构建也是如此，我们总是希望花最少的人力，最少的硬件设备条件，撑起最大的并发。当然理想总是那么的丰满，现实总是那么的骨感。虽说如此，但是我们不能没有理想，万一实现了呢？所以我们还是怀着敬畏的心，在构建高性能服务器的征途上奋力前行。</p>
<hr>
<h1 id="性能指标">性能指标 </h1><p>服务器的性能指标很多，而且<strong>相互之间还有着关联</strong>。</p>
<h2 id="1_吞吐率">1 吞吐率    </h2><p>如何判定服务器的性能状况呢？通常我们采用吞吐率来量化这个指标。所谓吞吐率，就是单位时间内服务器处理的请求数。注意，吞吐率有时候还用于描述其他指标，如单位时间内的通信数据量等。</p>
<p>当然，对于量化服务器性能这个指标，我们牢记，<strong>吞吐率就是单位时间内服务器处理的请求数，单位是reqs/s，有时也作rps</strong>，别无他意。</p>
<h2 id="2_CPU使用率，内存使用率，I/O_Wait率">2 CPU使用率，内存使用率，I/O Wait率  </h2><p>当然，服务器进程的CPU使用率，内存使用率，I/O Wait率也同样是评价服务器性能状况的重要指标。<strong>当CPU使用率较低，即CPU未跑满时（这里均是在压测情况下），说明服务器的瓶颈不在CPU上。同样，当内存使用率不高时，则说明服务器的瓶颈不在内存不够上</strong>。而至于I/O Wait率则不能简单的评价了。I/O Wait，它是指CPU空闲并且等待I/O操作完成的时间比例。但是，I/O Wait往往不能真实地代表I/O操作的情况或者工作量，它的设计出发点是用来衡量CPU性能的。假设有一任务需要花费10毫秒的I/O操作时间和10毫秒的CPU时间，那么I/O Wait率则为50%，这时并不意味着I/O操作的繁忙程度为50%。同样，I/O Wait为0%时，I/O操作也可能很繁忙。所以我们如果关心服务器的I/O情况的话，可以进行磁盘I/O测试或者查看网络I/O流量等。事实上，<strong>从I/O Wait率上，我们可以猜测服务器进程是I/O密集型的还是CPU密集型的</strong>。</p>
<h2 id="3_系统负载">3 系统负载</h2><p>在进程调度器维护的运行队列中，任何时刻至少存在一个进程，那就是正在运行的进程。而当运行队列中有不止一个进程的时候，就说明此时CPU比较忙碌，其他进程还在等待正在运行的进程释放CPU的执行权限。</p>
<p>所以系统负载也是影响服务器性能的指标之一。<strong>系统负载，即当然系统中等待CPU处理的进程数</strong>，所以系统负载越高，服务器进程得到CPU时间片愈发困难，从而影响服务器性能的下降。</p>
<h2 id="4_进程上下文切换">4 进程上下文切换</h2><p>我们知道，操作系统中运行着不止一个进程，而进程数通常又是远远大于CPU核心数。所以进程不得不面对一个事实：<strong>轮流使用CPU进行运算</strong>。而当进程之间轮流占有CPU资源时，就会出现CPU上下文切换的过程，理所当然，这个过程不是免费的，也具有一定的开销。</p>
<p>所以服务器进程上下文切换也会影响服务器的性能。<strong>当服务器CPU上下文切换频繁时，切换上下文的消耗则不能忽视</strong>。所以，适时查看服务器进程上下文切换频率也同样有助于构建高性能的服务器。</p>
<h2 id="5_系统调用数">5 系统调用数</h2><p><strong>进程有用户态和内核态两种运行模式</strong>，进程可以在这两种运行模式之间切换。进程通常运行在用户态下，而进行需要对硬件外设进行操作时，如读取硬盘文件，发送网络数据等，进程就需要切换至内核态运行。</p>
<p><strong>事实上这两种模式的切换对高级语言开发者来说是透明的，开发者只需要在需要的时候调用系统调用即可</strong>。内核提供了一系列系统调用函数，如read(), send()等。所以<strong>系统调用数从另一方面反应了用户态和内核态之间的切换数</strong>。</p>
<p>当然，用户态和内核态之间的切换也是需要开销的，所以构建高性能服务器的过程中，对系统调用数的统计亦不能忽视。</p>
<hr>
<h1 id="如何测试">如何测试</h1><h2 id="1_吞吐率-1">1 吞吐率</h2><p>通常，我们关心的是服务器的最大吞吐率，即每秒最多能处理多少个请求，事实上就是平常我们所说的服务器压力测试。当然，压力测试工具有好多种，如<a href="http://en.wikipedia.org/wiki/Apache_JMeter" target="_blank" rel="external">JMeter</a>，<a href="http://en.wikipedia.org/wiki/HP_LoadRunner" target="_blank" rel="external">LoadRunner</a>等。当然，还有Apache附带的<a href="http://en.wikipedia.org/wiki/ApacheBench" target="_blank" rel="external">ab</a>工具。下面，我们以ab为例，简单测试下百度首页的情况。</p>
<pre><code>ab -c10 -n100 www<span class="class">.baidu</span><span class="class">.com</span>
</code></pre><p>相应的结果如下（部分）：</p>
<pre><code>Concurrency <span class="string">Level:</span>      <span class="number">10</span>
Time taken <span class="keyword">for</span> <span class="string">tests:</span>   <span class="number">9.031</span> seconds
Complete <span class="string">requests:</span>      <span class="number">100</span>
Failed <span class="string">requests:</span>        <span class="number">97</span>
   (<span class="string">Connect:</span> <span class="number">0</span>, <span class="string">Receive:</span> <span class="number">0</span>, <span class="string">Length:</span> <span class="number">97</span>, <span class="string">Exceptions:</span> <span class="number">0</span>)
Total <span class="string">transferred:</span>      <span class="number">8730133</span> bytes
HTML <span class="string">transferred:</span>       <span class="number">8645328</span> bytes
Requests per <span class="string">second:</span>    <span class="number">11.07</span> [#/sec] (mean)
Time per <span class="string">request:</span>       <span class="number">903.139</span> [ms] (mean)
Time per <span class="string">request:</span>       <span class="number">90.314</span> [ms] (mean, across all concurrent requests)
Transfer <span class="string">rate:</span>          <span class="number">943.99</span> [Kbytes/sec] received
</code></pre><p>从上述测试中可以得到，我们对百度首页利用ab进行简单的压力测试（总共100次请求且并发数为10）总共花了9.031秒，那平均每个请求处理时间为90.314毫秒，但是由于并发数为10，所以每个用户的平均等待时间为903.139毫秒。当然，我们这里不评价百度首页的性能情况。</p>
<h2 id="2_CPU使用率，内存使用率，I/O_Wait率-1">2 CPU使用率，内存使用率，I/O Wait率</h2><p>我们查看服务器进程的CPU使用率，内存使用率，I/O Wait率可以直接使用linux的<strong>top命令</strong>，结果如下所示：</p>
<pre><code>top - 21:47:41 up 50 min,  3 users,  load average: 0.01, 0.02, 0.05
Tasks: 379 total,   1 running, 378 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   2042180 total,  1025404 used,  1016776 free,    48868 buffers
KiB Swap:   521212 total,        0 used,   521212 free.   501296 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 2190 zhujief+  20   0 1171408  98036  63920 S   0.7  4.8   0:31.79 compiz
  177 root      20   0       0      0      0 S   0.3  0.0   0:03.20 kworker/1:1
 1436 root      20   0  319448  62368  22940 S   0.3  3.1   0:14.96 Xorg
</code></pre><p>从top命令的结果中可以得到诸多有用的信息，如当前compiz进程的CPU使用率为0.7%，内存使用率为4.8%，具体使用为98036Kb物理内存。同样也可以看到I/O Wait率为0.0%，因为当前机器并没有跑任何I/O较为密集的程序。另外，iostat命令也可以查看I/O Wait情况。</p>
<h2 id="3_系统负载-1">3 系统负载</h2><p>通过<strong>查看/proc/loadavg</strong>文件内容，可以了解到当前运行队列的情况，即系统负载情况。运行如下命令:</p>
<pre><code>cat /<span class="keyword">proc</span>/loadavg
</code></pre><p>得到如下：</p>
<pre><code><span class="number">0.00 0.01</span> <span class="number">0.05 1/51</span>2 5082
</code></pre><p>即在过去1分钟，5分钟，15分钟内平均系统负载为0.00，0.01，0.05，即平均分别有0.00，0.01，0.05个进程正在等待。而1/512表示当前总共有512个进程，但是当前运行队列中只有1个进程。最右边的5082为最后创建的进程的进程ID。</p>
<h2 id="4_进程上下文切换-1">4 进程上下文切换</h2><p>利用<a href="http://nmon.sourceforge.net/pmwiki.php" target="_blank" rel="external">nmon</a>工具可以查看进程上下文切换情况。</p>
<pre><code>RunQueue         <span class="number">1</span>       Load Average    CPU use since boot time              
ContextSwitch    <span class="number">168.3</span>     <span class="number">1</span> mins  <span class="number">0</span>. <span class="number">00</span>   Uptime <span class="variable">Days=</span>  <span class="number">0</span> <span class="variable">Hours=</span> <span class="number">1</span> <span class="variable">Mins=</span><span class="number">59</span>   
Forks             <span class="number">0.0</span>        <span class="number">5</span> mins  <span class="number">0.02</span>    Idle   <span class="variable">Days=</span>  <span class="number">0</span> <span class="variable">Hours=</span> <span class="number">3</span> <span class="variable">Mins=</span><span class="number">53</span>   
Interrupts         <span class="number">70.9</span>   <span class="number">15</span> mins  <span class="number">0.05</span>    Average CPU <span class="variable">use=</span>-<span class="number">95.54</span>%           
</code></pre><p>从上面的结果可以看到，当前系统上下文切换速度为168.3/s。</p>
<h2 id="5_系统调用数-1">5 系统调用数</h2><p>同样，在linux下我们可以利用相关工具查看进程的系统调用情况 — <a href="http://linux.die.net/man/1/strace" target="_blank" rel="external">strace</a>。截取小段结果如下：</p>
<pre><code>recvmsg<span class="list">(<span class="number">5</span>, <span class="number">0</span>x7fffe94c5540, <span class="number">0</span>)</span>           = <span class="number">-1</span> EAGAIN <span class="list">(<span class="keyword">Resource</span> temporarily unavailable)</span>
recvmsg<span class="list">(<span class="number">5</span>, <span class="number">0</span>x7fffe94c5540, <span class="number">0</span>)</span>           = <span class="number">-1</span> EAGAIN <span class="list">(<span class="keyword">Resource</span> temporarily unavailable)</span>
poll<span class="list">([{fd=5, events=POLLIN|POLLOUT}], <span class="number">1</span>, <span class="number">4294967295</span>)</span> = <span class="number">1</span> <span class="list">([{fd=5, revents=POLLOUT}])</span>
writev<span class="list">(<span class="number">5</span>, [{<span class="string">"\213\n\2\0\327`\340\0"</span>, <span class="number">8</span>}, {NULL, <span class="number">0</span>}, {<span class="string">""</span>, <span class="number">0</span>}], <span class="number">3</span>)</span> = <span class="number">8</span>
</code></pre><p>很明显，在截取的结果中，进程分别进行了recvmsg, poll, writev等系统调用，当然也就进行了用户态和内核态的切换。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/28//2014/12-28-2.html/" itemprop="url">
                经典算法巡礼(七) -- 排序之堆排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-28T00:00:00+08:00" content="12月 28 2014">
            12月 28 2014
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一、优先队列">一、优先队列</h2><p>很多时候，我们需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。比如你可能启动了若干个定时器，那么下一次处理定时器事件只需要考虑距离现在时间最近的定时器即可，定时器触发时间无须全部有序，只需要处理优化级最高的定时器即可。</p>
<p>这种情况下，一个合适的数据结构应该支持两种操作：<strong>删除最小元素</strong>和<strong>插入元素</strong>。而且这两种操作的效率应该在可接受范围之内。这种数据类型叫<a href="http://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97" target="_blank" rel="external"><strong>优先队列</strong></a>。</p>
<h2 id="二、堆的定义">二、堆的定义</h2><p><a href="http://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="external"><strong>二叉堆</strong></a>能够很好的实现<strong>优先队列</strong>的基本操作。在二叉堆中，每个元素都要保证大于等于它的孩子结点。相应的，这些孩子结点同样要大于等于它们的孩子结点，以此类推。当然，这样的二叉堆又称<strong>最大堆</strong>。与最大堆类似，若每个元素均小于等于它的孩子结点，则称<strong>最小堆</strong>。之前提到的定时器触发问题，它所适合的数据结构应该为最小堆。</p>
<h2 id="三、二叉堆表示法">三、二叉堆表示法</h2><p>二叉堆是<a href="http://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">完全二叉树</a>，因此可以只用数组来表示二叉堆。具体方法是将二叉树的结点按照层级顺序放入数组中，根结点放在位置1，它的子结点放在位置2和3，而子结点的子结点则放在位置4，5，6，7，以此类推。而事实上，很容易就可以在数组中表示二叉树，即位置k的结点，它的子结点在数组中的位置则为2k和2k+1。</p>
<h2 id="四、堆的操作">四、堆的操作</h2><p>在堆的有序化过程中，我们会碰到以下两种情况：</p>
<ul>
<li>当某个结点的优先级上升(或者在堆底中加入一个新的元素)时，我们需要<strong>由下至上</strong>恢复堆的有序性；</li>
<li>当某个结点的优先级下降(比如根结点被替换为一个新的元素)时，我们需要<strong>由上至下</strong>恢复堆的有序列性。</li>
</ul>
<p>为了解决以上两个问题，就有了下面将要描述的<strong>上浮(swin)</strong>和<strong>下沉(sink)</strong>操作。</p>
<p><strong>由下至上的有序化（上浮）</strong></p>
<p>由于某结点的变化，造成了该结点比它的父结点更大（最大堆情况），从而影响了堆的有序性。比如堆中有新的元素加入堆底，而该新加入元素又比它的父结点更大，则需要将其与它的父结点交换位置，从而恢复它及其父结点的有序性。当然，这个过程会不停重复，直至堆中元素全部有序为止。整个过程就是之前所说的由下至上的上浮过程。具体<a href="https://golang.org/" target="_blank" rel="external">golang</a>可参考如下：</p>
<pre><code>func (<span class="keyword">this</span> *HeapPQ) swim(idx <span class="keyword">int</span>) {
    <span class="keyword">for</span> idx &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.less(idx/<span class="number">2</span>, idx) == <span class="keyword">true</span> {
        <span class="keyword">this</span>.exch(idx/<span class="number">2</span>, idx)
        idx /= <span class="number">2</span>
    }
}
</code></pre><p><strong>由上至下的有序化（下沉）</strong>  </p>
<p>由于某结点的变化，造成了该结点比它的子结点更小（最大堆情况），从而影响了堆的有序性。比如删除堆中根结点的元素，并原先在堆底的元素放置于根结点位置。事实上这就是最大堆中取最大元素的操作。当然，为了保持堆的有序性，则对新的根结点进行下沉操作，若根结点比它的子结点中的任意一个小，则将根结点与此结点交换，同时将该子结点进行重复操作，直到堆恢复有序性为止。整个过程就是之前的说的由上至下的下沉过程。具体<a href="https://golang.org/" target="_blank" rel="external">golang</a>可参考如下：</p>
<pre><code>func (<span class="keyword">this</span> *HeapPQ) sink(idx <span class="keyword">int</span>) {
    <span class="keyword">for</span> <span class="number">2</span>*idx &lt;= <span class="keyword">this</span>.Size() {
        child := 2 * idx
        <span class="keyword">if</span> child &lt; <span class="keyword">this</span>.Size() &amp;&amp; <span class="keyword">this</span>.less(child, child+1) == <span class="keyword">true</span> {
            child++
        }
        <span class="keyword">if</span> <span class="keyword">this</span>.less(idx, child) != <span class="keyword">true</span> {
            <span class="keyword">break</span>
        }
        <span class="keyword">this</span>.exch(idx, child)
        idx = child
    }
}
</code></pre><h2 id="五、堆排序">五、堆排序</h2><p>堆排序可以分为两个阶段：</p>
<ul>
<li><strong>堆的构造阶段</strong></li>
<li><strong>下沉排序阶段</strong></li>
</ul>
<p>构造一个堆，可以用以下两种方法进行。第一种，从左至右遍历数组，用swin()保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可。第二种，事实上是更聪明更高效的方法。就是<strong>从右至左用sink()函数构造子堆</strong>。开始时我们只需要扫描数组中的一半元素，所以是更高效的方法。</p>
<p>第二个阶段，即下沉排序阶段，我们可以将堆中最大元素删除，然后放入堆缩小后数组空出的位置。</p>
<p>整个过程用代码表述如下：</p>
<pre><code>func (<span class="keyword">this</span> *HeapSort) sink(a []Comparable, i <span class="typename">int</span>, j <span class="typename">int</span>, compare Compare) {
    <span class="string">b :</span>= a[<span class="string">i:</span>j]
    b = append(make([]Comparable, <span class="number">1</span>), b...)
    <span class="string">size :</span>= len(b) - <span class="number">1</span>

    func(idx <span class="typename">int</span>) {
        <span class="keyword">for</span> <span class="number">2</span>*idx &lt;= size {
            <span class="string">child :</span>= <span class="number">2</span> * idx
            <span class="comment">// fmt.Println(idx, child, size)</span>
            <span class="keyword">if</span> child &lt; size &amp;&amp; compare(b[child], b[child+<span class="number">1</span>]) &lt; <span class="number">0</span> {
                child++
            }
            <span class="keyword">if</span> compare(b[idx], b[child]) &lt; <span class="number">0</span> {
                <span class="keyword">this</span>.exch(b, idx, child)
                idx = child
                <span class="keyword">continue</span>
            }
            <span class="keyword">break</span>
        }
    }(<span class="number">1</span>)

    copy(a[<span class="string">i:</span>j], b[<span class="number">1</span>:])
}

<span class="comment">// Sort中参数类型Comparable为统一的可比较接口，若为整数数组排序，则Comparable为int即可</span>
<span class="comment">// Sort中参数类型Compare为配合Comparable接口的比较方法，若为整数数组排序，则Compare即满足a int &lt; a int即可</span>
func (<span class="keyword">this</span> *HeapSort) Sort(a []Comparable, compare Compare) {
    <span class="string">n :</span>= len(a)

    <span class="comment">// 堆构造</span>
    <span class="keyword">for</span> <span class="string">i :</span>= n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- {
        <span class="keyword">this</span>.sink(a, i, n, compare)
    }

    <span class="comment">// 堆排序的下沉阶段</span>
    <span class="keyword">for</span> <span class="string">i :</span>= n - <span class="number">1</span>; i &gt; <span class="number">1</span>; {
        <span class="keyword">this</span>.exch(a, <span class="number">0</span>, i)
        i--
        <span class="keyword">this</span>.sink(a, <span class="number">0</span>, i, compare)
    }
}
</code></pre><p>至于堆排序的效率，在sink()函数中，比较操作最多进行2logN次，所以排序整个数组最多需要N<em>2logN次比较操作，因此<em>*堆排序的时间复杂度为O(NlogN)</em></em>，所以可以用于大规模数据的排序。</p>
<p><strong>堆排序是能够同时最优地利用空间和时间的方法，即使在最坏的情况下，它也能保证使用~2NlogN次比较和恒定的额外空间</strong>。但现代系统的许多应用很少使用它，因为<strong>堆排序无法有效利用缓存</strong>。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序，归并排序，甚至是希尔排序（希尔排序算是没有多少相信元素间的比较的算法了）。</p>
<p>但是，<strong>用堆实现优先队列在现代应用程序中却起着重要的作用，因为它能在插入操作和删除最大元素操作保证对数级别的运行时间（logN）</strong>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/28//2014/12-28-1.html/" itemprop="url">
                经典算法巡礼(六) -- 排序之快速排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-28T00:00:00+08:00" content="12月 28 2014">
            12月 28 2014
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">快速排序</a>正如她的名字，她是一种排序效率相当高的算法，而且<strong>可能是应用最广泛</strong>的排序算法了。快速排序流行的原因是她<strong>实现简单，适用于各种不同的输入数据且在一般应用中比其他排序算法都要快</strong>。不仅如此，她与<a href="http://codingforever.cn/2014/12-28-0.html" target="_blank" rel="external">归并排序</a>不同，她<strong>只需要很小的辅助空间就可以进行排序</strong>。</p>
<p>快速排序也是<a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms" target="_blank" rel="external"><strong>分治思想</strong></a>的典型应用。她与<a href="http://codingforever.cn/2014/12-28-0.html" target="_blank" rel="external">归并排序</a>是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序而是当两个子数组都有序时，整个数组也就自己有序了。前者的递归调用发生在处理整个数组之前，而后者的递归调用发生在处理整个之后。</p>
<p>快速排序最主要的操作就是patition，即<strong>切分操作</strong>。选择数组中一元素，以该元素做为基准切分元素，姑且将其称为P，切分后使P之前的所有元素都小于P(排序成递增序列)，P之后的所有元素都大于P。然后对P切分成的两个子数组分别再一次进行切分操作。重复此过程直到不能切分为止，即整个数组排序完成。</p>
<p>那么如何选择这个切分基准元素P呢？通常是随机取数组中任意值，所以快速排序的效率是和概率相关的，但实际使用过程中排序效率还是非常可观的。具体<a href="https://golang.org/" target="_blank" rel="external">golang</a>实现如下： </p>
<pre><code><span class="comment">// partition方法即为快速排序中重要的切分操作，以首元素做为基准，将剩余元素从两端寻找，分别找到大于（小于）基准的元素并交换，重复此过程直到剩余元素全部遍历为止</span>
func (<span class="keyword">this</span> *QuickSort) partition(a []Comparable, compare Compare, lo <span class="typename">int</span>, hi <span class="typename">int</span>) <span class="typename">int</span> {
    <span class="string">i :</span>= lo + <span class="number">1</span>
    <span class="string">j :</span>= hi
    <span class="string">v :</span>= a[lo]
    <span class="keyword">for</span> <span class="literal">true</span> {
        <span class="keyword">for</span> <span class="keyword">this</span>.less(a[i], v, compare) == <span class="literal">true</span> {
            <span class="keyword">if</span> i == hi {
                <span class="keyword">break</span>
            }
            i++
        }
        <span class="keyword">for</span> <span class="keyword">this</span>.less(a[j], v, compare) == <span class="literal">false</span> {
            <span class="keyword">if</span> j == lo {
                <span class="keyword">break</span>
            }
            j--
        }
        <span class="keyword">if</span> i &gt;= j {
            <span class="keyword">break</span>
        }
        <span class="keyword">this</span>.exch(a, i, j)
        i++
        j--
    }
    <span class="keyword">this</span>.exch(a, lo, j)

    <span class="keyword">return</span> j
}

<span class="comment">// Sort中参数类型Comparable为统一的可比较接口，若为整数数组排序，则Comparable为int即可</span>
<span class="comment">// Sort中参数类型Compare为配合Comparable接口的比较方法，若为整数数组排序，则Compare即满足a int &lt; a int即可</span>
func (<span class="keyword">this</span> *QuickSort) Sort(a []Comparable, compare Compare, lo <span class="typename">int</span>, hi <span class="typename">int</span>) {
    <span class="keyword">if</span> hi &lt;= lo {
        <span class="keyword">return</span>
    }

    <span class="string">p :</span>= <span class="keyword">this</span>.partition(a, compare, lo, hi)
    <span class="keyword">this</span>.Sort(a, compare, lo, p-<span class="number">1</span>)
    <span class="keyword">this</span>.Sort(a, compare, p+<span class="number">1</span>, hi)
}
</code></pre><p>上述实现过程在切分操作时，只是简单取数组第一个元素做为切分基准元素。如此做法，<strong>排序效率则与输入序列相关了，因此可以在排序之前shuffee数组，如此一来就与概率相关了</strong>。</p>
<p>分析快速排序的过程，可以得到每次patition时，需要N-1次比较操作（数组元素为N的情况下），同时又可得到此patition过程需要进行logN次。因此，整个快速排序需要<strong>(N-1)logN ~ NlogN</strong>次比较操作，也就是说其<strong>时间复杂度为O(NlogN)</strong>。因此，她也是<strong>可以应用于大规模数组的排序，而且也不需要<a href="http://codingforever.cn/2014/12-28-0.html" target="_blank" rel="external">归并排序</a>大量的额外空间，同时也没有<a href="http://codingforever.cn/2014/12-27-3.html" target="_blank" rel="external">希尔排序</a>的不确定性</strong>。</p>
<p>当然，其实快速排序有一种方便的改进，即可在对有大量相同元素的数组排序时，效率大大提高。她是由<a href="http://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="external">Dijkstra</a>提出的“<strong>三向切分的快速排序</strong>“。具体实现如下：</p>
<pre><code><span class="comment">// Sort方法采用”三向切分的快速排序“法进行排序</span>
func (<span class="keyword">this</span> *QuickSort) Sort(a []Comparable, compare Compare, lo <span class="typename">int</span>, hi <span class="typename">int</span>) {
    <span class="keyword">if</span> hi &lt;= lo {
        <span class="keyword">return</span>
    }

    <span class="string">lt :</span>= lo
    <span class="string">i :</span>= lo + <span class="number">1</span>
    <span class="string">gt :</span>= hi

    <span class="string">v :</span>= a[lo]
    <span class="keyword">for</span> i &lt;= gt {
        <span class="string">cmp :</span>= compare(v, a[i])
        <span class="keyword">if</span> cmp &lt; <span class="number">0</span> {
            <span class="keyword">this</span>.exch(a, i, gt)
            gt--
        } <span class="keyword">else</span> <span class="keyword">if</span> cmp &gt; <span class="number">0</span> {
            <span class="keyword">this</span>.exch(a, i, lt)
            i++
            lt++
        } <span class="keyword">else</span> {
            i++
        }
    }
    <span class="keyword">this</span>.Sort(a, compare, lo, lt-<span class="number">1</span>)
    <span class="keyword">this</span>.Sort(a, compare, gt+<span class="number">1</span>, hi)
}
</code></pre><p>“三向切分的快速排序”中的切分方法过程如下：  </p>
<p>她遍历数组一次，维护一个指针lt使得a[lo..lt-1]中的元素都小于v(即切分基准元素)，一个指针gt使得a[gt+1..hi]中的元素都大于v，一个指针i使得a[lt..i-1]全部等于v，而a[i..gt]中的元素都还未确定。正如上述代码中所示，等遍历完数组后，数组就分为三部分，a[lo..lt-1]为小于v的部分，a[gt+1..hi]为大于v的部分，而a[lt..gt]则为等于v的部分。然后，对不等于v的部分数组再次切分递归，直到不能切分为止。  </p>
<p>而<strong>如果数组中有大量相同元素时，采用”三向切分“方法就不会对相同部分再次进行重复比较，大大提高排序性能。而当没有重复元素时，”三向切分“方法又等同时原始快速排序</strong>。因此，”三向切分的快速排序“通常被用于实际场合中进行快速排序。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/28//2014/12-28-0.html/" itemprop="url">
                经典算法巡礼(五) -- 排序之归并排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-28T00:00:00+08:00" content="12月 28 2014">
            12月 28 2014
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="external">归并排序</a>是创建在<strong>归并操作</strong>上的一种有效排序算法。<strong>所谓归并操作，指的是将两个已经排序的序列合并成一个序列的操作</strong>。归并排序是<a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms" target="_blank" rel="external"><strong>分治思想</strong></a>的典型示范。</p>
<p>归并排序具体步骤如下：</p>
<ol>
<li>申请大小等于两个已排序序列之和的空间，该空间用来存放合并后的序列；</li>
<li>设定两个指针，初始位置分别为两个已排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择较小的元素放入合并的空间中（若进行升序排序），并移动指针到下一个位置；</li>
<li>重复步骤3直至其中某一指针到达序列尾；</li>
<li>将另一序列剩下的元素直接复制到合并序列中。</li>
</ol>
<p>用<a href="https://golang.org/" target="_blank" rel="external">golang</a>实现如下： </p>
<pre><code>// <span class="built_in">merge</span>方法实现归并排序中的归并操作，将两个已排序数组归并操作成一个已排序数组
func (this *MergeSort) <span class="built_in">merge</span>(<span class="operator">a</span> []Comparable, compare Compare, lo int, <span class="keyword">mid</span> int, hi int) {
    i := lo
    j := <span class="keyword">mid</span> + <span class="number">1</span>

    arrayBak := make([]Comparable, <span class="built_in">len</span>(<span class="operator">a</span>))
    copy(arrayBak, <span class="operator">a</span>)

    <span class="keyword">for</span> k := lo; k &lt;= hi; k++ {
        <span class="keyword">if</span> i &gt; <span class="keyword">mid</span> {
            <span class="operator">a</span>[k] = arrayBak[j]
            j++
        } <span class="keyword">else</span> <span class="keyword">if</span> j &gt; hi {
            <span class="operator">a</span>[k] = arrayBak[i]
            i++
        } <span class="keyword">else</span> <span class="keyword">if</span> this.less(arrayBak[i], arrayBak[j], compare) {
            <span class="operator">a</span>[k] = arrayBak[i]
            i++
        } <span class="keyword">else</span> {
            <span class="operator">a</span>[k] = arrayBak[j]
            j++
        }
    }
}
<span class="comment">
// Sort1采用自顶向下方法进行归并排序</span><span class="comment">
// Sort中参数类型Comparable为统一的可比较接口，若为整数数组排序，则Comparable为int即可</span><span class="comment">
// Sort中参数类型Compare为配合Comparable接口的比较方法，若为整数数组排序，则Compare即满足a int &lt; a int即可</span>
func (this *MergeSort) sort1(<span class="operator">a</span> []Comparable, compare Compare, lo int, hi int) {
    <span class="keyword">if</span> lo &gt;= hi {
        <span class="constant">return</span>
    }

    <span class="keyword">mid</span> := (lo + hi) / <span class="number">2</span>

    this.sort1(<span class="operator">a</span>, compare, lo, <span class="keyword">mid</span>)
    this.sort1(<span class="operator">a</span>, compare, <span class="keyword">mid</span>+<span class="number">1</span>, hi)
    this.<span class="built_in">merge</span>(<span class="operator">a</span>, compare, lo, <span class="keyword">mid</span>, hi)
}
<span class="comment">
// Sort2采用自底向上方法进行归并排序，先从子数组为1开始归并操作，逐渐递增，直到归并成完整数组为止</span><span class="comment">
// Sort中参数类型Comparable为统一的可比较接口，若为整数数组排序，则Comparable为int即可</span><span class="comment">
// Sort中参数类型Compare为配合Comparable接口的比较方法，若为整数数组排序，则Compare即满足a int &lt; a int即可</span>
func (this *MergeSort) sort2(<span class="operator">a</span> []Comparable, compare Compare) {
    <span class="keyword">for</span> sz := <span class="number">1</span>; sz &lt; <span class="built_in">len</span>(<span class="operator">a</span>); sz += sz {
        <span class="keyword">for</span> lo := <span class="number">0</span>; lo &lt; <span class="built_in">len</span>(<span class="operator">a</span>)-sz; lo += sz + sz {
            this.<span class="built_in">merge</span>(<span class="operator">a</span>, compare, lo, lo+sz-<span class="number">1</span>, int(math.Min(float64(lo+sz+sz-<span class="number">1</span>), float64(<span class="built_in">len</span>(<span class="operator">a</span>)-<span class="number">1</span>))))
        }
    }
}
</code></pre><p>下面我们来考虑下归并排序的效率问题。首先我们假设数组有N个元素，而N的值为2^n，所以采用归并排序的过程，可以用如下图的树状图表示：</p>
<p><img src="/img/2014-12-28-0.png" alt="树状图" title="树状图"></p>
<p>图中每一个结点都表示一个merge()方法归并而成的一个数组。这棵树正好有n层。对于0到n-1之间的任意k，自顶向下的第k层有2^k个子数组，每个子数组又包含有2^(n-k)元素，所以归并操作最多需要2^(n-k)次比较。因此，每层的比较操作次数为2^n次，所以n次总共需要n<em>2^n次比较操作。又由于N=2^n，所以归并排序整个数组最多需要n</em>2^n=NlogN次比较操作。当然，每次归并操作最少需要2^(n-k)/2次比较，所以归并排序整个数组的话，最小需要NlogN/2次比较操作。综合上述分析，<strong>归并排序需要NlogN/2至NlogN次比较操作</strong>，因此其<strong>时间复杂度是线性对数型的，即O(NlogN)</strong>。</p>
<p>可见，<strong>归并排序是适合用于大规模数据排序</strong>的算法。但不要忘了，归并排序有个明显的缺陷，即她需要申请与排序数组相同大小的数组进行归并操作，在空间利用方面并不是十分理想，因此可能<strong>不适合用于空间不宽裕的场合</strong>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/12/27//2014/12-27-2.html/" itemprop="url">
                经典算法巡礼(三) -- 排序之插入排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2014-12-27T00:00:00+08:00" content="12月 27 2014">
            12月 27 2014
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="external">插入排序</a>，与之前的<a href="http://codingforever.cn/2014/12-27-0.html" target="_blank" rel="external">冒泡排序</a>和<a href="http://codingforever.cn/2014/12-27-1.html" target="_blank" rel="external">选择排序</a>一样，其名称就说明了她的原理。所谓插入排序，就是对于数组中未排序的元素，依次遍历寻找合适的位置并插入到已排序的子数组中。当数组中没有未排序的元素时，插入排序即完成。</p>
<p>同样，还是先展示<a href="https://golang.org/" target="_blank" rel="external">golang</a>实现的版本：</p>
<pre><code><span class="comment">// Sort方法从数组头开始，将未排序的元素依次选择合适的位置插入已排序的子数组中</span>
<span class="comment">// 这里并不是找到合适位置后再将元素插入，而是交换元素至合适位置</span>
<span class="comment">// Sort中参数类型Comparable为统一的可比较接口，若为整数数组排序，则Comparable为int即可</span>
<span class="comment">// Sort中参数类型Compare为配合Comparable接口的比较方法，若为整数数组排序，则Compare即满足a int &lt; a int即可</span>
func (this *InsertionSort) Sort(a []Comparable, compare Compare) <span class="comment">{
    for i := 1; i &lt; len(a); i++ {
        for j := i; j &gt; 0 &amp;&amp; this.less(a[j], a[j-1], compare); j-- {
            this.exch(a, j, j-1)
        }</span>
    }
}要
</code></pre><p>还是与之前一样，我们以数组元素的比较作为一次操作，分析插入排序其效率如何。事实上，在最差情况下，采用插入排序需要的比较次数为<strong>0+1+2+…+N-1</strong>次，简化后即为<strong>(N-1)/2*N = (N^2-N)/2 ~ N^2</strong>。而在最好的情况下，排入排序需要的比较次数则为<strong>N-1</strong>次。</p>
<p>可见，插入排序的<strong>时间复杂度是O(N^2)</strong>，同样是万恶的<strong>平方级别</strong>。但是，与<a href="http://codingforever.cn/2014/12-27-0.html" target="_blank" rel="external">冒泡排序</a>和<a href="http://codingforever.cn/2014/12-27-1.html" target="_blank" rel="external">选择排序</a>不同，插入排序所需的比较次数是<strong>与输入数组相关的</strong>，在最差的情况下才需要N^2次的操作。然而事实就是事实，插入排序还是<strong>只适用于小型数组的排序，不能满足大量数据的排序</strong>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhujiefirst" itemprop="image"/>
          <p class="site-author-name" itemprop="name">zhujiefirst</p>
        </div>
        <p class="site-description motion-element" itemprop="description">学习总结 思考感悟 知识管理</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhujiefirst</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  

  



  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  
  

  







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
