<!doctype html>
<html class="theme-next use-motion ">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="学习总结 思考感悟 知识管理" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="Codingforever">
<meta property="og:url" content="http://codingforever.com/page/4/index.html">
<meta property="og:site_name" content="Codingforever">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codingforever">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

    <title> Codingforever </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Codingforever</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2013/06/23//2013/06-23-0.html/" itemprop="url">
                编程语言与编程思维杂感
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2013-06-23T00:00:00+08:00" content="6月 23 2013">
            6月 23 2013
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/编程思维/" itemprop="url" rel="index"><span itemprop="name">编程思维</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><strong>“编程语言不仅仅是一种技术，它更是一种思维。” －－ Paul Graham</strong></p>
<p>以前经常看到这样的言论：“什么C/C++，Java, C#等等都是编程语言而已，实现你想法的工具，学好一门语言，以不变应万变，就算用其他语言也是差不多的，只是工具变了而已。”这样的说法真心有失偏颇。没错，什么语言都只是工具，但他们不仅仅是工具，也包含了用这种工具时候所形成的思维方式。</p>
<p>“著名的语言学家Roman Jakobson曾用一句简单的名言指明了语言之间最关键的不同之处：语言之间的不同本质在于它们能够传达的信息，而不是它们不能传达的信息。这句名言告诉了我们解放我们母语潜能的关键所在：不同的语言用不同的方式影响我们的大脑思维，这并不是因为这种语言可以让我们这样思考问题，而是它在强迫你这样思考。”<br>“当你的语言日常的强迫你去使用某些类型的信息进行说明，这会迫使你去留意那些使用其它种语言的人平时不会注意的某些细节和体验。因为这种说法的习惯是从小养成的，这种习惯已经成为大脑思维的习惯，超越了语言本身，直接影响了你的言行，感知，联想，感觉，记忆，以及世界观。”</p>
<p>Jokobson的名言同样也适合于编程语言界，不同语言对于程序员的思维要求并不是一样的。如C语言作为一门过程性语言，给予程序员的思维就是过程性的，先做什么，后做什么，任何一个步骤都是线性过程思维。而Java给我们带来的是一切均为对象的思维，当程序员码出任何一行代码之前所思考的是如何构成当前这个对象，该对象有何数据，有何处理这些数据的方法。所以，两种程序员码出来的代码是完全两种风格的。</p>
<p>C和Java两种程序员码出来的代码当然是两种风格的，这有什么大惊小怪的。但是同样两位Java程序员码出来的Java代码也是风格各异，同样的工具，在不同思维的带领下，就会产生不同的结果。</p>
<p>举个例子，有一棵Tree，遍历其结点，并进行打印各结点的值。</p>
<p>Example 1:</p>
<pre><code><span class="keyword">class</span> Tree {
<span class="keyword">public</span>:
    Tree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; children);
    ~Tree();

    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">visitAll</span><span class="params">()</span></span>;

    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span><span class="keyword">const</span> </span>{ <span class="keyword">return</span> m_name; }

<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; m_children;
    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;
};

Tree::Tree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; children)
    : m_name(name),
      m_children(children)
{

}

Tree::~Tree()
{
    for_each(m_children.begin(), m_children.end(), [](Tree* child){ <span class="keyword">delete</span> child; });
}

<span class="keyword">void</span> Tree::visit()
{
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::endl;
}

<span class="keyword">void</span> Tree::visitAll(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Tree*)&gt; action)
{
    visit(action);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_children.size(); ++i) {        m_children[i]-&gt;visitAll(action);
    }
}

<span class="keyword">static</span> Tree* constructTree()
{
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; v;
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; emptyVector;
    v.push_back(<span class="keyword">new</span> Tree(<span class="string">"left child"</span>, emptyVector));
    v.push_back(<span class="keyword">new</span> Tree(<span class="string">"right child"</span>, emptyVector));

    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="string">"root"</span>, v);
}

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructTree</span><span class="params">(Tree* t)</span>
</span>{
    <span class="keyword">delete</span> t;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Tree* root = constructTree();

    root-&gt;visitAll();

    destructTree(root);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>没错，上述实现方法的确可行，但是如果遍历每一个结点，具体的操作由客户(依然是程序员)来决定，那又如何？似乎思路被堵住了。奥秘如下：</p>
<p>Example 2:</p>
<pre><code><span class="keyword">class</span> Tree {
<span class="keyword">public</span>:
    Tree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; children);
    ~Tree();

    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Tree*)</span>&gt; action)</span>;

    <span class="function"><span class="keyword">void</span> <span class="title">visitAll</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Tree*)</span>&gt; action)</span>;

    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span><span class="keyword">const</span> </span>{ <span class="keyword">return</span> m_name; }

<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; m_children;
    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;
};

Tree::Tree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; children)
    : m_name(name),
      m_children(children)
{

}

Tree::~Tree()
{
    for_each(m_children.begin(), m_children.end(), [](Tree* child){ <span class="keyword">delete</span> child; });
}

<span class="keyword">void</span> Tree::visit(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Tree*)&gt; action)
{
    action(<span class="keyword">this</span>);
}

<span class="keyword">void</span> Tree::visitAll(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Tree*)&gt; action)
{
    visit(action);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_children.size(); ++i) {        m_children[i]-&gt;visitAll(action);
    }
}

<span class="keyword">static</span> Tree* constructTree()
{
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; v;
    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Tree*&gt; emptyVector;
    v.push_back(<span class="keyword">new</span> Tree(<span class="string">"left child"</span>, emptyVector));
    v.push_back(<span class="keyword">new</span> Tree(<span class="string">"right child"</span>, emptyVector));

    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="string">"root"</span>, v);
}

<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructTree</span><span class="params">(Tree* t)</span>
</span>{
    <span class="keyword">delete</span> t;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Tree* root = constructTree();

    root-&gt;visitAll([](Tree* t) { <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t-&gt;getName() &lt;&lt; <span class="built_in">std</span>::endl; });

    destructTree(root);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>相当巧妙的思维，其实也是受一段ruby代码的启发，不同的程序语言的思维的启发。所以大神们说，每年至少学习一门新的编程语言是相当有道理的。当然我们学习它并不是为了把它使用在工作中（若是能使用那再好不过，因为实践是最好的老师），而是学习该语言随之而来的编程思维，如同简单的遍历Tree一样。</p>
<p>最后，附上启发这篇怪文的Ruby源码。</p>
<pre><code>class <span class="constant">Tree</span>
    attr_accessor <span class="symbol">:children</span>, <span class="symbol">:node_name</span>

    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(name, children = [])
        <span class="variable">@children</span> = children
        <span class="variable">@node_name</span> = name
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">visit_all</span></span>(&amp;block)
        visit(&amp;block)
        children.each { |c| c.visit_all &amp;block }
    <span class="keyword">end</span>

    <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(&amp;block)
        block.call <span class="keyword">self</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

ruby_tree = <span class="constant">Tree.</span>new(<span class="string">"Ruby"</span>,
    [<span class="constant">Tree.</span>new(<span class="string">"Reia"</span>),
        <span class="constant">Tree.</span>new(<span class="string">"MacRuby"</span>)])

puts <span class="string">"Visiting a node"</span>
ruby_tree.visit { |node| puts node.node_name }

puts <span class="string">"Visiting entire tree"</span>
ruby_tree.visit_all { |node| puts node.node_name }
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2013/06/22//2013/06-22-0.html/" itemprop="url">
                First-class Funciton's Cry
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2013-06-22T00:00:00+08:00" content="6月 22 2013">
            6月 22 2013
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/编程思维/" itemprop="url" rel="index"><span itemprop="name">编程思维</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>what’s First-class function? 没听过啊。小猿我也才前几天头一回听说。<br>直接引用wiki上的原话：In computer science, a programming language is said to have first-class functions if it treats functions ad first-class citizens. Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures.</p>
<p>What? 这就是“<strong>一等函数</strong>”啊。以C/C++谋生的小猿感觉有点熟悉啊。这不就是函数指针吗？答案是：NO! 函数指针只是C/C++在其函数类型不是first-class object的情况下而所用的替代品。</p>
<p>那First-class function到底有什么好处呢？说实话，小猿也说不清楚(水平太次)，只能用以 Lua VS C 简略说明下其不同之处，各位看官莫要见笑。</p>
<h2 id="ROUND_1"><strong>ROUND 1</strong></h2><p>Lua首先很轻松地支持高阶函数（什么是高阶函数，参见<a href="http://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">wiki</a>）。</p>
<p>lua版本：</p>
<pre><code><span class="comment">-- higher-order functions: passing functions as arguments</span>
<span class="comment">-- @param f 函数</span>
<span class="comment">-- @param t 函数f的参数</span>
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span><span class="params">(f, t)</span></span>
    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span>
        f(v)
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>哈哈，不就是如此嘛，C语言这位大神也可以轻松搞定：</p>
<p>C版本：</p>
<pre><code><span class="comment">// higher-order functions: passing functions as arguments</span>
<span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(<span class="keyword">int</span> (*f)</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)
</span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {
        f(arr[i]);
    }
}
</code></pre><h2 id="ROUND_2"><strong>ROUND 2</strong></h2><p>lua 轻松搞定匿名函数。</p>
<p>lua版本：</p>
<pre><code>-- anonymous and nested functions
map(<span class="function"><span class="keyword">function</span><span class="params">(v)</span></span> <span class="built_in">print</span>(v) <span class="keyword">end</span>, { <span class="number">1</span>, <span class="number">2</span> }) -- <span class="function"><span class="keyword">function</span></span> map is defined <span class="type">in</span> <span class="keyword">ROUND</span> <span class="number">1</span>
</code></pre><p>C大神流了点汗，也使出相应招术。</p>
<p>C版本：</p>
<pre><code><span class="comment">// not support anonymous and nested functions, have to bind it to a name instead</span>
<span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"%d"</span>, v);
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
    <span class="built_in">map</span>(print, arr, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h2 id="ROUND_3"><strong>ROUND 3</strong></h2><p>lua 使用<a href="http://en.wikipedia.org/wiki/Closure_%28computer_science%29" target="_blank" rel="external">cloures</a>绝招。</p>
<p>lua版本：</p>
<pre><code><span class="comment">-- non-local variables and closures</span>
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span>
    <span class="keyword">local</span> offset = <span class="number">10</span>
    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span><span class="params">(f, t)</span></span>
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span>
            f(v)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    map(<span class="function"><span class="keyword">function</span><span class="params">(v)</span></span> offset = offset + v <span class="built_in">print</span>(offset) <span class="keyword">end</span>, { <span class="number">1</span>, <span class="number">2</span> })
<span class="keyword">end</span>
main()
</code></pre><p>C虽然没有明显的吃亏，但已然快招架不住。</p>
<p>C版本：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">void</span> (*f) (<span class="keyword">int</span>);
    <span class="keyword">int</span>* offset;
} <span class="keyword">closure_t</span>;
<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);
}
<span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(closure_t closure, <span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span>
</span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {
        *(closure.offset) += arr[i];
        closure.f(*(closure.offset));
    }
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> offset = <span class="number">10</span>;
    <span class="keyword">closure_t</span> closure = { print, &amp;offset };
    <span class="keyword">int</span> arr[] = { <span class="number">1</span>, <span class="number">2</span> };
    <span class="built_in">map</span>(closure, arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h2 id="ROUND_4:"><strong>ROUND 4:</strong></h2><p>lua又使用一招返回函数:</p>
<p>Lua版本：</p>
<pre><code><span class="comment">-- higher-order functions: returning functions as reuslt</span>
<span class="comment">-- Assigning functions to variables</span>
<span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrintFunc</span><span class="params">()</span></span>
    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">myPrint</span><span class="params">(v)</span></span>
        <span class="built_in">print</span>(v)
    <span class="keyword">end</span>
    <span class="keyword">return</span> myPrint
<span class="keyword">end</span>
<span class="keyword">local</span> func = getPrintFunc()
func(<span class="number">1</span>)
</code></pre><p>C以它老江湖的经验接住了此招。</p>
<p>C版本：</p>
<pre><code><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*f)</span><span class="params">(<span class="keyword">int</span>)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> v)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);
}
<span class="function">f <span class="title">getPrintFunc</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> print;
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    f func = getPrintFunc();
    func(<span class="number">1</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>比武结束，当然以已之长攻他之短并不是十分光彩的事，但是这里也是为了说明理解First-class function的方便之处。其实First-class function在高阶函数中还是很有用的，当然实际工作中，如果用到闭包、匿名函数则其方便之处不言而喻。当然，具体情况还是具体分析，我们是辩证法的推崇者嘛。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2013/03/25//2013/03-25-0.html/" itemprop="url">
                原地排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2013-03-25T00:00:00+08:00" content="3月 25 2013">
            3月 25 2013
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><strong>题目：</strong><br>Given an unsorted array of size n containing objects with ids of 0 … n-1, sort the array in place and inlinear time. Assume that the objects contain large members such as binary data, so instantiating new copies of the objects is probibitively expensice.</p>
<p>用另一种表达方式：有一串数字，5, 2, 6, 7, 4, 1, 8, 9, 0, 3, 用O(n)的时间复杂度来实现排序，当然只允许多分配少量临时变量。</p>
<p>当然，如果有一般的排序算法，最快也就O(nlogn).　那么是否有更好的解决方法吗？由于题设的特殊性，当然有更好的方法。</p>
<p><strong>Linus说，“Talk is cheep. Show me the code.” 所以直接上代码，show you the code!</strong></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> "stdio.h"</span>
<span class="preprocessor">#<span class="keyword">include</span> "stdlib.h"</span>

<span class="keyword">int</span>* general_array(<span class="keyword">int</span> len)
{
    <span class="keyword">int</span> i;
    <span class="keyword">int</span>* <span class="built_in">array</span>;

    <span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
        <span class="built_in">array</span>[i] = i;
    }

    <span class="keyword">return</span> <span class="built_in">array</span>;
}

<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* lhs, <span class="keyword">int</span>* rhs)</span>
</span>{
    <span class="keyword">int</span> tmp;

    tmp = *lhs;
    *lhs = *rhs;
    *rhs = tmp;
}

<span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span>
</span>{
    <span class="keyword">int</span> i;

    srand((<span class="keyword">int</span>)time(NULL));

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
        swap(&amp;<span class="built_in">array</span>[rand()%len], &amp;<span class="built_in">array</span>[i]);
    }
}

<span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span>
</span>{
    <span class="keyword">int</span> i;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
        <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">array</span>[i]);
    }
    <span class="built_in">printf</span>(<span class="string">"\n"</span>);
}

<span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span>
</span>{
    <span class="keyword">int</span> i, count = <span class="number">0</span>;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
        <span class="keyword">if</span> (<span class="built_in">array</span>[i] != i) {
            swap(&amp;<span class="built_in">array</span>[i], &amp;<span class="built_in">array</span>[<span class="built_in">array</span>[i]]);
            ++count;
        }
    }

    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> arrayLen;
    <span class="keyword">int</span>* <span class="built_in">array</span>;

    arrayLen = <span class="number">10</span>;
    <span class="built_in">array</span> = general_array(arrayLen);

    shuffle(<span class="built_in">array</span>, arrayLen);
    print_array(<span class="built_in">array</span>, arrayLen);

    sort(<span class="built_in">array</span>, arrayLen);
    print_array(<span class="built_in">array</span>, arrayLen);

    <span class="built_in">free</span>(<span class="built_in">array</span>);

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2013/03/24//2013/03-24-0.html/" itemprop="url">
                Calling Convention on X86 -- Using C for Example
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2013-03-24T00:00:00+08:00" content="3月 24 2013">
            3月 24 2013
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>引用wikipedia上的定义：In computer science, a calling convention is a scheme for how subroutines receive parameters from their caller and how they return a result，即规定了子过程如何从它们的调用者那里取得参数并且返回结果的一种约定。它包含如下5点：</p>
<ol>
<li>参数与返回值存放的位置，可以在寄存器中，也可以在调用栈中，又或者两种都有</li>
<li>向子过程传递参数的顺序，或者单个参数的部分。</li>
<li>调用前设置工作和调用后清理工作，如何在调用者与被调用者之间分配。</li>
<li>哪些寄存器可以直接被被调用者使用。</li>
<li>哪些寄存器可以被认为是volatile和或者non-volatile，若为volatile，则无需被调用者恢复。</li>
</ol>
<p>不同的的程序语言使用不同的调用约定，也可以运行在不同的平台之上，包括不同的CPU架构和不同的操作系统。正是如此，若整合用不同程序语言写的模块，或者调用不同程序语言所写的操作系统或者类库的API时可能会出现问题。正是由于存在这种问题，所以才有了调用约定的必要性。  </p>
<p>通常，一种程序语言存在多种不同的调用约定，可以由编译器所规定，也可以出于优化的情况而由程序员所指定。而不同的CPU架构也有不同的调用约定，比如X86与ARM就有不同的数量的寄存器，当然在其平台上的调用约定也是不同的。</p>
<p>这里我们先来了解一下X86架构的调用约定。  </p>
<p>X86架构拥有几种不同的调用约定。但由于其寄存器数量较少，其调用约定通常将参数存放在调用栈上，将返回值(或者其地址)存放在寄存器中。当然还有一些调用约定将参数存放入寄存器中，这类调用约定对一些参数较少同时又是leaf-routies调用将会提高不少性能(invoked frequently)。</p>
<h2 id="一、调用者清理的调用约定：">一、调用者清理的调用约定：</h2><p>这类调用约定由调用者清理保存在栈上各个参数，典型如变参函数printf()。</p>
<p><strong>1.　cdecl</strong><br>cdecl为C　declaration的缩写，是一种起源于C语言的调用约定。目前常用于X86架构上的多种编译器中，如VC的编译器就是默认cdecl为种调用约定。在该种调用约定中，子过程的参数被保存在栈上传递，整型返回值与内存地址通过EAX寄存器返回，浮点值则存入STO X87寄存器中返回。</p>
<p>在C语言的上下文(content)中，函数的参数以从右到左的顺序压入栈中。看下面个段C语言代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">callee</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">caller</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">register</span> <span class="keyword">int</span> ret;

    ret = callee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
    ret += <span class="number">5</span>;
    <span class="keyword">return</span> ret;
}
</code></pre><p>在X86上，上述C语言代码将成为如下汇编(AT&amp;T syntax):</p>
<pre><code>.globl  <span class="keyword">caller</span>
<span class="keyword">caller</span>:
pushl   <span class="variable">%ebp</span>            ; 将上次保存栈顶压栈
movl    <span class="variable">%esp</span>, <span class="variable">%ebp</span>      ; 保存栈顶
pushl   <span class="variable">$3</span>              ; 参数压栈
pushl   <span class="variable">$2</span>              ; 参数压栈
pushl   <span class="variable">$1</span>              ; 参数压栈
call    callee          ; subroutines
addl    <span class="variable">$1</span>2, <span class="variable">%esp</span>       ; 退栈
addl    <span class="variable">$5</span>, <span class="variable">%eax</span>        ; 将subrouties返回的值加常量<span class="number">5</span>
leave
ret
</code></pre><p>研究以上汇编，可见参数是由调用者在调用完成后清理的。这里是简单的整型返回，那如果是复杂的Struct呢，寄存器放不下了！一些编译器将复杂Struct通过内存来返回。首先调用者分配一片内存然后将其地址当作隐藏的第一个参数传入子过程中，在子过程中处理这片内存，最后将这个地址返回。当然，这只是众多处理方法中的一种而已。</p>
<h2 id="二、被调用者清理的调用约定：">二、被调用者清理的调用约定：  </h2><p>栈上的参数由被调用者来清理有一个前提，那就是在编译期间要明确有几个字节在栈上。因此，这类调用约定不适用于变参函数，如printf()。</p>
<p><strong>1 pascal</strong><br>该调用约定是基于Pascal语言的调用约定，其参数压栈顺序为从左至右，在返回前由被调用者负责清理栈帧</p>
<p><strong>2 stdcall</strong><br>该调用约定是pascal调用约定的变化版本，其参数从右至左压栈，然后由被调用者负责清理杠，返回值存入EAX寄存器中。stdcall调用约定为Win32 API的标准调用约定。</p>
<p><strong>3 fastcall</strong><br>该调用约定没有标准化，故各编译器各有不同。其中经典的为将一个或者多个参数存放寄存器中，从而减少内存的读取。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2012/09/09//2012/09-09-0.html/" itemprop="url">
                观察者模式(Observer Pattern)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2012-09-09T00:00:00+08:00" content="9月 9 2012">
            9月 9 2012
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式(Observer patten)</a>，<strong>定义了对象之间的一对多依赖，这样一来一个对象改变状态时，它的所有依赖者都会收到通知并自动更新</strong>。</p>
<p>它在现实生活中也非常常见，如报纸、杂志的订阅关系。比如Bob向报社订阅了《程序员》，《程序员》供应商就将Bob加入订阅者的表格中。每次新的《程序 员》一出版，就会通知Bob：新一期《程序员》出版了，并同时将《程序员》送到Bob手中。过了半年，Bob不想再订阅《程序员》了，因了他订阅了 ipad版的。这时，《程序员》供应商就将Bob从订阅者表格中删除。以后每月新一期《程序员》出版时，就不再通知Bob，并送杂志到他手中了。</p>
<p>没错，这就是观察者模式，并不复杂。很多地方都用到这个模式，如著名的<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="external">MVC(Model-View-controler)</a>中重要的部分就是观察者模式，而Swing中也存在着观察者模式的实现。</p>
<p>下面，我们具体来分析一下这个强大的观察者模式。</p>
<p>观察者模式可以分为主题(Subject)和观察者(Observer)。主题其实就是被观察者对象，就如上面杂志订阅中的杂志社，而观察者就是各个订阅 者。杂志社可以将新的订阅者加入订阅者列表中，也可以加老是订阅者从订阅者列表中删除，所以主题类也拥有这两种能力，即拥有 registerObserver( )和removeObserver( )方法(方法名称仅仅是名称而已，可用其他)。而且，杂志社可以通知各个订阅者新杂志到了，所以主题类也有相应的方法：notifObservers( )。而观察者呢？杂志社通知订阅都有新的杂志到了，订阅者就有相应的动作，或阅读，或送人。当然，观察者类则有update( )方法与之对应。对应的UML图如下：</p>
<p><img src="/img/2012-09-09-0.png" alt="UML图" title="UML图"></p>
<p>那么，这个观察者模式有什么好处呢？<strong>观察者模式提供了一种对象设计，让主题和观察者之间松耦合</strong>(还记得学校里老师教的“强内聚，松耦合”吗)。</p>
<p>在主题方，它对观察者基本不知道任何详情，只知道观察者实现了某个接口，其他具体细节一概不知，如具体类是什么，有多少种方法，各种方法内又做了什么。主 题只要维护好自己的观察者列表和其他数据，在新的观察者申请加入时，将其加入列表；在理的观察者申请退出时，将其从列表中删除；在自己的数据更新时，依次 通知各个观察者，即调用它们的update方法(上段中update方法)。如果主题类增加维护数据时，已有的观察者们都无须更新代码，因为这只与主题类 相关，这就是松耦合的威力。</p>
<p>在观察者方，它只关心所观察对象(即主题类)推送过来的更新消息，取得自己感兴趣的数据，做自己相应的动作，而无需知道被观察者(主题)具体有多少观察 者，有多少数据，或者是肥是瘦。而如果不想观察这个主题，则调用主题remove方法将自己从主题的观察者列表中删除，不影响该主题和其他观察者。</p>
<p>可见，改变主题或者观察者的任何一方都不会影响另一方，这就是松耦合。</p>
<p>附<a href="http://book.douban.com/subject/2243615/" target="_blank" rel="external">《Head First 设计模式》</a>中相应章节源代码，以更方便理解观察者模式。Java中Observable类与Observer类就是相应的被观察者(主题类)与观察者:</p>
<pre><code><span class="keyword">package</span> com.Observor;  

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayEmlement</span> </span>{  
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  
}
</code></pre><hr>
<pre><code><span class="keyword">package</span> com.Observor;  

<span class="keyword">import</span> java.util.Observable;  

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>{  
    <span class="keyword">private</span> <span class="keyword">float</span> temperature;  
    <span class="keyword">private</span> <span class="keyword">float</span> humidity;  
    <span class="keyword">private</span> <span class="keyword">float</span> pressure;  

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementChanged</span><span class="params">()</span> </span>{  
        setChanged();  
        notifyObservers();  
    }  

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidigy, <span class="keyword">float</span> pressure)</span> </span>{  
        <span class="keyword">this</span>.temperature = temperature;  
        <span class="keyword">this</span>.humidity = humidigy;  
        <span class="keyword">this</span>.pressure = pressure;  
        measurementChanged();  
    }  

    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> temperature;  
    }  

    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> humidity;  
    }  

    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>{  
        <span class="keyword">return</span> pressure;  
    }  
}
</code></pre><hr>
<pre><code><span class="keyword">package</span> com.Observor;  

<span class="keyword">import</span> java.util.Observable;  
<span class="keyword">import</span> java.util.Observer;  

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayEmlement</span> </span>{  
    Observable observable;  
    <span class="keyword">private</span> <span class="keyword">float</span> temerature;  
    <span class="keyword">private</span> <span class="keyword">float</span> humidity;  

    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Observable observable)</span> </span>{  
        <span class="keyword">this</span>.observable = observable;  
        observable.addObserver(<span class="keyword">this</span>);  
    }  

    <span class="annotation">@Override</span> 
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{  
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub  </span>
        System.out.println(<span class="string">"Current conditions: "</span> + temerature + <span class="string">"F degrees and "</span> + humidity + <span class="string">"% humidity"</span>);  
    }  

    <span class="annotation">@Override</span> 
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable arg0, Object arg1)</span> </span>{  
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub  </span>
        <span class="keyword">if</span> (arg0 <span class="keyword">instanceof</span> WeatherData) {  
            WeatherData weatherData = (WeatherData)arg0;  
            <span class="keyword">this</span>.temerature = weatherData.getTemperature();  
            <span class="keyword">this</span>.humidity = weatherData.getHumidity();  
            display();  
        }  
    }  

}
</code></pre><hr>
<pre><code><span class="keyword">package</span> com.Observor;  

<span class="keyword">import</span> java.util.Observable;  
<span class="keyword">import</span> java.util.Observer;  

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayEmlement</span> </span>{  
    <span class="keyword">private</span> <span class="keyword">float</span>  currentPressure = <span class="number">29.92f</span>;  
    <span class="keyword">private</span> <span class="keyword">float</span> lastPressure;  

    <span class="function"><span class="keyword">public</span> <span class="title">ForecastDisplay</span><span class="params">(Observable observable)</span> </span>{  
        observable.addObserver(<span class="keyword">this</span>);  
    }  

    <span class="annotation">@Override</span> 
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{  
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub  </span>
        System.out.println(<span class="string">"lastPressure: "</span> + lastPressure + <span class="string">" curPressure:"</span> + currentPressure);  
    }  

    <span class="annotation">@Override</span> 
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>{  
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub  </span>
        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> WeatherData) {  
            lastPressure = currentPressure;  
            currentPressure = ((WeatherData) o).getPressure();  
        }  
        display();  
    }  

}
</code></pre><hr>
<pre><code><span class="keyword">package</span> com.Observor;  

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>{  

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  
        WeatherData weatherData = <span class="keyword">new</span> WeatherData();  

        CurrentConditionsDisplay currentDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);  
        ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);  
        weatherData.setMeasurements(<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>);  <span class="comment">// 数字乱来的哦  </span>
        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  
        weatherData.setMeasurements(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);  
    }  
}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2012/09/02//2012/09-02-0.html/" itemprop="url">
                策略模式(Strategy Pattern)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2012-09-02T00:00:00+08:00" content="9月 2 2012">
            9月 2 2012
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>学习Object Oriented(OO)也有段时间了，但一直没有学习Pattern Design方面的东西，感觉使用OO的时候完全不给力啊。So, balabala……..</p>
<p>Sorry，扯了一点废话。</p>
<p>Strategy Pattern，在WikiPedia中解释为：a particularsoftware design pattern, whereby algorithms can be selected at runtime. 也就是说，Strategy Pattern在运行时能够改变算法的一种设计模式。那么，这个算法是什么呢？这里的算法，指的是Object的行为，比如一个Duck，它拥有Fly的行为，但是运行时改变算法，使其can’t Fly。这就是Strategy Pattern的优势所在。当然，《Head First 设计模式》中对它也有定义：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p>OK,我们以《Head First 设计模式》中的例子来说明。</p>
<p>我们要设计以下两个类，MallarDuck(绿头鸭)和RedheadDuck(红头鸭)。既然都是Duck(鸭)，会OO的人都会想到－－inherit(继承)。那这两种鸭子有什么共有的特性，我们可以将它们抽象出来放入一个父类Duck中呢。哦，它们都会quack，还有swim!于是，有了下面的设计：</p>
<p><img src="/img/2012-09-02-0.png" alt="UML图" title="UML图"></p>
<p>嗯，看起来不错的样子。但是过了一天，老板(产品经理，又或者其他**，你明白的)说，我们要新的功能，MallardDuck和RedheadDuck都要有fly( )的行为！嗯，不怕，OO的好处来了。只要在Duck类中新加入fly( )行为，这下所有的子类都有fly( )的行为了，一切OK！</p>
<p><img src="/img/2012-09-02-1.png" alt="UML图" title="UML图"></p>
<p>等等，让我想想，真的OK吗？第3天，**（who?）又说，我们仅有MallardDuck与RedheadDuck太少了，我们需要一个RubberDuck ! OK，so easy。</p>
<p><img src="/img/2012-09-02-2.png" alt="UML图" title="UML图"></p>
<p>Hold on ! RubberDuck好像不会飞啊。但是为什么RubberDuck有fly( )这个行为！那也行，好吧，在RubberDuck中覆盖fly( )方法，但是什么也不做吧。</p>
<pre><code><span class="keyword">class</span> <span class="title">RubberDuck</span> <span class="title">extend</span> <span class="title">Duck</span> {
    ......
    @<span class="function"><span class="keyword">override</span>
    <span class="keyword">public</span> <span class="title">fly</span>(<span class="params"></span>) </span>{
        <span class="comment">// do nothing</span>
    }
    ......
}
</code></pre><p>看上去还成。但是如果不止增加RubberDuck呢，还有ModelDuck， 以及<strong>Duck, balabala……..那不是每个类都要覆盖fly( )方法？你怎么知道只有fly( )方法。要是</strong>Duck不会swim呢（我们假设有这样一种Duck）？OMG，我的OO呢，说好的方便呢？</p>
<p>嘿，谁说没有好方法。且看：</p>
<p><img src="/img/2012-09-02-3.png" alt="UML图" title="UML图"></p>
<p>这下，谁看要什么方法就让它有吧，想要fly( )方法，就实现Flyable这个接口；想要quack方法，就实现Quackable接口。Oh, No ! 这不是N多代码重复吗！MallardDuck与RedheadDuck的fly( )方法是一样的啊，说好的代码复用呢？</p>
<p>等等，好像灵感又来了！代码复用？参考Duck类的做法不就行了！</p>
<p><img src="/img/2012-09-02-4.png" alt="UML图" title="UML图"></p>
<p>Oh, 终于告一段落了，这样就可以了！再等等！什么，还有？！学习OO的时候，前人都告诫说：少用继承，多用组合。似乎继承过多了。。。还是多重的。。。那再修改！</p>
<p><img src="/img/2012-09-02-5.png" alt="UML图" title="UML图"></p>
<p>这么修改，还增加了一个功能：运行时可以替换Object的行为啊，组合果然是个good choice !</p>
<p>其实，最后一个版本就是刚开始就提到的Strategy Pattern， 真是“千呼万唤始出来”啊。</p>
<p>另外，附上最终的Java代码，让我们更好的理解它。</p>
<p>Duck.java:</p>
<pre><code><span class="comment">// Duck.java</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Duck</span> {

    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>(<span class="params"></span>) </span>{

    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span>(<span class="params"></span>)</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span>(<span class="params"></span>)</span>{
        flyBehavior.fly();
    }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span>(<span class="params"></span>) </span>{
        quackBehavior.quack();
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span>(<span class="params"></span>) </span>{
       System.<span class="keyword">out</span>.println(<span class="string">"All ducks float, even decoys!"</span>);
   }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span>(<span class="params">FlyBehavior fb</span>) </span>{
        flyBehavior = fb;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span>(<span class="params">QuackBehavior qb</span>) </span>{
        uackBehavior = qb;
    }
}
</code></pre><p>FlyBehavior.java:</p>
<pre><code><span class="comment">// FlyBehavio.java</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">FlyBehavior</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span>(<span class="params"></span>)</span>;
}
</code></pre><p>FlyWithWings.java:</p>
<pre><code>// <span class="type">FlyWithWings</span>
public class <span class="type">FlyWithWings</span> implements <span class="type">FlyBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> fly() {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"I'am flying!"</span>);
    }

}
</code></pre><p>FlyNoWay.java:</p>
<pre><code>// <span class="type">FlyNoWay</span>.java
public class <span class="type">FlyNoWay</span> implements <span class="type">FlyBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> fly() {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"I can't fly!"</span>);
    }

}
</code></pre><p>FlyRockedPowered.java:</p>
<pre><code>// <span class="type">FlyRockedPowered</span>
public class <span class="type">FlyRockedPowered</span> implements <span class="type">FlyBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> fly() {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"I' am flying with a rocked!"</span>);
    }

}
</code></pre><p>QuackBehavior.java:</p>
<pre><code><span class="comment">// QuackBehavior.java</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">QuackBehavior</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span>(<span class="params"></span>)</span>;
}
</code></pre><p>Quack.java</p>
<pre><code>// <span class="type">Quack</span>.java
public class <span class="type">Quack</span> implements <span class="type">QuackBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> quack() {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Quack"</span>);
    }

}
</code></pre><p>MuteQuack.java</p>
<pre><code>// <span class="type">QuackBehavior</span>.java
public class <span class="type">MuteQuack</span> implements <span class="type">QuackBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> quack() {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"&lt;&lt; Silence &gt;&gt;"</span>);
    }

}
</code></pre><p>Squeak.java</p>
<pre><code>// <span class="type">Squeak</span>.java
public class <span class="type">Squeak</span> implements <span class="type">QuackBehavior</span> {

    @<span class="type">Override</span>
    public <span class="type">void</span> quack() {
         // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
         <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"Squeak"</span>);
    }

}
</code></pre><p>MallardDuck.java:</p>
<pre><code><span class="comment">// MallardDuck</span>
public <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Duck</span> {</span>

    public <span class="type">MallardDuck</span>() {
        quackBehavior = <span class="keyword">new</span> <span class="type">Quack</span>();
        flyBehavior = <span class="keyword">new</span> <span class="type">FlyWithWings</span>();
    }

    <span class="annotation">@Override</span>
    public void display() {
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        <span class="type">System</span>.out.println(<span class="string">"I'm a real Mallard duck"</span>);
    }

}
</code></pre><p>ModelDuck.java:</p>
<pre><code><span class="comment">// ModelDuck</span>
public <span class="class"><span class="keyword">class</span> <span class="title">ModelDuck</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Duck</span> {</span>

    <span class="type">ModelDuck</span>() {
         flyBehavior = <span class="keyword">new</span> <span class="type">FlyNoWay</span>();
         quackBehavior = <span class="keyword">new</span> <span class="type">Quack</span>();
    }

    <span class="annotation">@Override</span>
    public void display() {
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        <span class="type">System</span>.out.println(<span class="string">"I'm a model duck!"</span>);
    }

}
</code></pre><p>Test.java</p>
<pre><code><span class="comment">// Test.java</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> {

    <span class="comment">/**
    * @param args
    */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        Duck mallard = <span class="keyword">new</span> MallardDuck();
        mallard.performFly();
        mallard.performQuack();

        System.<span class="keyword">out</span>.println(<span class="string">"------------------- now, change the duck! --------------------"</span>);

        Duck model = <span class="keyword">new</span> ModelDuck();
        model.performFly();
        System.<span class="keyword">out</span>.println(<span class="string">"------------------- now, set rocked on the model! --------------------"</span>);
        model.setFlyBehavior(<span class="keyword">new</span> FlyRockedPowered());
        model.performFly();
    }

}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2011/12/15//2011/12-15-0.html/" itemprop="url">
                序对的一种过程性表示
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2011-12-15T00:00:00+08:00" content="12月 15 2011">
            12月 15 2011
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/lisp/" itemprop="url" rel="index"><span itemprop="name">lisp</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>考虑这样一个问题，设计一个数据结构，使其表示有理数。</p>
<p>So easy!</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> rat{  
 <span class="keyword">int</span> num;  
 <span class="keyword">int</span> den;  
}rat;
</code></pre><p>其中，num表示该有理数的分子，den表示该有理数的分母，而整个数据结构rat即可表示为有理数。如果要得到该有理数的分子，可用rat.num表示，而rat.den则表示分母。</p>
<p>那么，如果不用数据结构，完全用过程来表示这样的数据，可行吗？</p>
<p>“一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及为使这些过程成为一套合法表示，它们就必须满足的一组特定条件。”————–SICP</p>
<p>我们定义这样三个过程，</p>
<ul>
<li>cons————–将两个对象粘接到一起</li>
<li>car—————-取出第一个对象</li>
<li>cdr—————-取出第二个对象</li>
</ul>
<p>其中，cons为构造函数，car和cdr为选择函数，而这些操作满足的条件就是：对任何对象x和y，如果z是(cons x y)，则(car z)为x，(cdr z)为y。</p>
<p>这样，我们确实能够完全不用任何数据结构，只使用过程就可以实现序对。如下：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> x y)</span>  
     <span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword">dispatch</span> m)</span>  
            <span class="list">(<span class="keyword"><span class="built_in">cond</span></span> <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">=</span></span> m <span class="number">0</span>)</span> x)</span>  
                  <span class="list">(<span class="list">(<span class="keyword"><span class="built_in">=</span></span> m <span class="number">1</span>)</span> y)</span>  
                  <span class="list">(<span class="keyword"><span class="built_in">else</span></span> <span class="list">(<span class="keyword">error</span> <span class="string">"Argument not 0 or 1 ---------CONS"</span> m)</span>)</span>)</span>)</span>  
     dispatch)</span>  

<span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">car</span></span> z)</span> <span class="list">(<span class="keyword">z</span> <span class="number">0</span>)</span>)</span>  
<span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> z)</span> <span class="list">(<span class="keyword">z</span> <span class="number">1</span>)</span>)</span>
</code></pre><p>上面是采用Lisp实现的，但是用C呢？</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> "stdio.h"  </span>

<span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFunToDispatch)</span><span class="params">(<span class="keyword">int</span>)</span></span>;  

<span class="function">pFunToDispatch <span class="title">pairConstructor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  
</span>{  
    <span class="function"><span class="keyword">int</span> <span class="title">dispatch</span><span class="params">(<span class="keyword">int</span> m)</span>  
    </span>{  
        <span class="keyword">return</span> (m == <span class="number">0</span>) ? x : y;  
    }  

    <span class="keyword">return</span> dispatch;  
}  

<span class="function"><span class="keyword">int</span> <span class="title">firstOfPair</span><span class="params">(pFunToDispatch pair)</span>  
</span>{  
    <span class="keyword">return</span> (*pair)(<span class="number">0</span>);  
}  

<span class="function"><span class="keyword">int</span> <span class="title">secondOfPair</span><span class="params">(pFunToDispatch pair)</span>  
</span>{  
    <span class="keyword">return</span> (*pair)(<span class="number">1</span>);  
}  

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  
</span>{  
    pFunToDispatch pair = pairConstructor(<span class="number">11</span>, <span class="number">12</span>);  

    <span class="keyword">int</span> first = (*pair)(<span class="number">0</span>);  
    <span class="keyword">int</span> second = (*pair)(<span class="number">1</span>);  

    <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, first, second);  

    <span class="keyword">return</span> <span class="number">0</span>;  
}
</code></pre><p>注意，由于ANSI C并不支持函数的嵌套定义，所以上述函数只适用在GCC中，而且可能会出问题，见<a href="http://tieba.baidu.com/p/1192690362?pn=1。" target="_blank" rel="external">http://tieba.baidu.com/p/1192690362?pn=1。</a></p>
<p>补充：</p>
<p>序对用过程性表示的另一种方法：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cons</span></span> x y)</span>  
      <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">m</span>)</span> <span class="list">(<span class="keyword">m</span> x y)</span>)</span>)</span>  

<span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">car</span></span> z)</span>  
      <span class="list">(<span class="keyword">z</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> p)</span>)</span>)</span>  

<span class="list">(<span class="keyword"><span class="built_in">define</span></span> <span class="list">(<span class="keyword"><span class="built_in">cdr</span></span> z)</span>  
      <span class="list">(<span class="keyword">z</span> <span class="list">(<span class="keyword"><span class="built_in">lambda</span></span> <span class="list">(<span class="keyword">p</span> q)</span> q)</span>)</span>)</span>
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2011/10/16//2011/10-16-0.html/" itemprop="url">
                一个N个整数序列取M个数，使其概率相同问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2011-10-16T00:00:00+08:00" content="10月 16 2011">
            10月 16 2011
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这是今天上午在同济笔试百度的题目，当时没做出来，那个郁闷，现把思路放在此处纪念已逝的笔试。</p>
<p>原题大概是这样的：一个服务器一天内会收到很多request，但是服务器只能存放m个request，试设计一种算法，使得在时时的reqest中选择m个保存，并保证最后各个request被选中的概率为大致相同。记住，不到最后，不知道request的总数n.</p>
<p>其实，这个题目可以这样解：</p>
<p>前m个request依次放入服务器中，当第m+1个来临时，以m/(m+1)的概率选中，并在已保存的m个request中等概率选择一个替换之。当第m+2个来临时，以</p>
<p>m/(m+2)的概率选中，并在已保存的m个request中等概率选择一个替换之。 依次类推，第N个request以m/N的概率被选择，并在已保存的m个request中等概率选择一个替换之。最终每个request被选择的概率为m/n.</p>
<p>证明如下(数学归纳法）：</p>
<p>当n=m+1时，第m+1选中的概率为m/(m+1)，而第一个被选中的概率为：1/(m+1) + m/(m+1) * (m-1)/m = m/(m+1);</p>
<p>假设当n = N时，每个request被选择的概率为m/N;</p>
<p>现证明当n = N+1时，每个request被选择的概率为m / (N+1).</p>
<p>第N+1个被选中的概率当然为m/(N+1)，而第一个request被选择的概率为：m/N <em> ( (N+1-m)/(N+1) + m/(N+1) </em> (m-1)/m = m / (N+1)；其余request被选择的概率也一样，得证当n = N+1时，每个request被选择的概率为m / (N+1)。</p>
<p>综上得，第方法可以实现最最终每个request被选择的为m/n.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2011/10/16//2011/10-16-0.html/" itemprop="url">
                编写高质量C语言代码 -- Assert Yourself
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2011-10-16T00:00:00+08:00" content="10月 16 2011">
            10月 16 2011
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>C语言中assert功能强大，人称“断言”，如语句assert ( expression )，即断言expression始终为true, 若为false，则程序运行失败。</p>
<p>但是，assert ( expression ) 看似function，但它其实是macro, 而且只是一个debug-only的宏，即只有在定义DEBUG宏的情况下才有用。但是它却是一个强大的高度工具，而且也是编码bug-free的code的有力助手。</p>
<p>举个例子，有以下这样一个function:</p>
<p>example 1:</p>
<pre><code><span class="comment">/* memcpy -- copy a nonoverlapping memory block */</span>
<span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)
{
    <span class="keyword">byte</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;
    <span class="keyword">byte</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;

    <span class="keyword">while</span>(<span class="keyword">size</span>-- &gt; <span class="number">0</span>)
        *pbTo = *pvFrom;

    <span class="keyword">return</span>(pvTo);
}
</code></pre><p>有经验的programmer一看就知道这是一个有bug的function。如果如此应用：</p>
<p>1.</p>
<pre><code>memcpy(<span class="keyword">NULL</span>, pvFrom, <span class="keyword">size</span>);
</code></pre><p>2.</p>
<pre><code>memcpy(pvTo, <span class="keyword">NULL</span>, <span class="keyword">size</span>);
</code></pre><p>就会出现问题。NULL是0，而对0地址解引用会出现什么事？SO BAD！</p>
<p>那么怎么办呢？在对pbTo与pvFrom解引用之前进行指针检查，进行如下改变：</p>
<p>example 2 :</p>
<pre><code><span class="comment">/* memcpy -- copy a nonoverlapping memory block */</span>
<span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)
{
    <span class="keyword">byte</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;
    <span class="keyword">byte</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;

    <span class="keyword">if</span>(pvTo == <span class="keyword">NULL</span> || pvFrom == <span class="keyword">NULL</span>){
        fprintf(stderr, <span class="string">"Bad args in memcpy\n"</span>);
        abort();
    }

    <span class="keyword">while</span>(<span class="keyword">size</span>-- &gt; <span class="number">0</span>)
        *pbTo++ = *pvFrom++;

    <span class="keyword">return</span>(pvTo);
}
</code></pre><p>OK， Perfect ！但是身为一个持有完美主义的coder，似乎这样的代码不是那么一回事。有人教导我们，编写代码的时候要有两个版本：Debug Version and Ship Version。我们新加的语句好像是Debug Version里的吧，怎么能让它出现在Ship Version里呢？于是乎：</p>
<p>example 3:</p>
<pre><code><span class="comment">/* memcpy -- copy a nonoverlapping memory block */</span>
<span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)
{
    <span class="keyword">byte</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;
    <span class="keyword">byte</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;

#ifdef DEBUG
    <span class="keyword">if</span>(pvTo == <span class="keyword">NULL</span> || pvFrom == <span class="keyword">NULL</span>){
         fprintf(stderr, <span class="string">"Bad args in memcpy\n"</span>);
         abort();
    }
#endif

    <span class="keyword">while</span>(<span class="keyword">size</span>-- &gt; <span class="number">0</span>)
        *pbTo++ = *pvFrom++;

    <span class="keyword">return</span>(pvTo);
}
</code></pre><p>这下没问题了吧？嗯，我们的主角assert呢？怎么没有？别急，马上就来，有句话不是说：英雄总是最后登场的嘛。注意我们加的Debug语句不就是在测试pvTo与pvFrom不为NULL吗？这不就是assert的功能！So:</p>
<p>example 4:</p>
<pre><code><span class="comment">/* memcpy -- copy a nonoverlapping memory block */</span>
<span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)
{
    <span class="keyword">byte</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;
    <span class="keyword">byte</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;

    assert(pvTo != <span class="keyword">NULL</span> &amp;&amp; pvFrom != <span class="keyword">NULL</span>);

    <span class="keyword">while</span>(<span class="keyword">size</span>-- &gt; <span class="number">0</span>)
        *pbTo++ = *pvFrom++;
    <span class="keyword">return</span>(pvTo);
}
</code></pre><p>嗯，好像可以了。但是~，如果pvTo与pvFrom指向的内存块是overlapped的呢？oh, no！所以还等断言pvTo与pvFrom是没有overlapped的。最终版登场：</p>
<p>example5:</p>
<pre><code><span class="comment">/* memcpy -- copy a nonoverlapping memory block */</span>
<span class="keyword">void</span>* memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)
{
    <span class="keyword">byte</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;
    <span class="keyword">byte</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;

    assert(pvTo != <span class="keyword">NULL</span> &amp;&amp; pvFrom != <span class="keyword">NULL</span>);
    assert(pvTo &gt;= pvFrom + <span class="keyword">size</span> || pvFrom &gt;= pbTo + <span class="keyword">size</span>);

    <span class="keyword">while</span>(<span class="keyword">size</span>-- &gt; <span class="number">0</span>)
        *pbTo++ = *pvFrom++;
    <span class="keyword">return</span>(pvTo);
}
</code></pre><p>小结：请使用assert 来code您的程序！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2011/10/07//2011/10-07-0.html/" itemprop="url">
                编写高质量C语言代码 -- API设计
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2011-10-07T00:00:00+08:00" content="10月 7 2011">
            10月 7 2011
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/c-c/" itemprop="url" rel="index"><span itemprop="name">c/c++</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>首先我们先来看一个程序：</p>
<pre><code><span class="label">char</span>* <span class="keyword">strdup(char* </span><span class="keyword">str)
</span>{
    char* <span class="keyword">strNew;
</span>
    <span class="keyword">strNew </span>= (char*)malloc(<span class="keyword">strlen(str) </span>+ <span class="number">1</span>)<span class="comment">;</span>
    <span class="keyword">strcpy(strNew, </span><span class="keyword">str);
</span>    return(<span class="keyword">strNew);
</span>}
</code></pre><p>上面这个程序会发生什么情况？如果malloc失败，strNew为NULL，oh, no！这个malloc也太难用了吧，老是忘记要判断返回值是否为NULL。没错，但这不是你的错，是malloc的错。为什么malloc函数返回值既 可能是新分配的地址，又可能是NULL，即表示malloc出错呢？如果malloc函数改成如下：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">malloc</span><span class="params">(<span class="keyword">void</span>* ptr, size_t size)</span></span>;
</code></pre><p>ptr为指向新分配内存的指针，size为新分配内存的大小，返回值为malloc成功与否。若是这样的malloc，你会用错吗？</p>
<p>还记得那万恶的getchar函数吗？对，它的原型是：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">()</span></span>;
</code></pre><p>为什么是int，而不是char呢？坑爹呢？有木有！有木有啊！无数次错误的用成：</p>
<pre><code>char <span class="built_in">c</span>;  

<span class="built_in">c</span> = getchar();  
<span class="keyword">if</span>(<span class="built_in">c</span> == <span class="type">EOF</span>)  
    ...
</code></pre><p>要是有更好的函数，鬼才愿意用这个函数！若是这样的原型：</p>
<pre><code><span class="function"><span class="keyword">bool</span> <span class="title">getchar</span><span class="params">(<span class="keyword">char</span>* c)</span></span>;
</code></pre><p>整个世界和谐了。<strong>Don’t mix error and other special-purpose values into your outputs of interfaces.</strong></p>
<p>这不是最坑爹的，且看下面的BOSS级函数：</p>
<pre><code><span class="keyword">void</span>* realloc(<span class="keyword">void</span>* pv, <span class="keyword">size_t</span> size);
</code></pre><p>在C library manual中有这样几句话（译）：</p>
<ol>
<li>如果pv为NULL， size不为0，则此函数相当于malloc(size);</li>
<li>如果size为0， pv不为NULL， 则此函数相当于free();</li>
<li>如果pv为NULL，size为0，则未定义。</li>
</ol>
<p>这怎么回事？这明明是realloc函数啊，怎么又出来malloc和free函数了。如果realloc能完成malloc和free函数的功 能，后面两个函数累赘了吧？还有，如果realloc失败，realloc返回的将是NULL。这又在坑爹啊，我多么想这么用啊：</p>
<pre><code>ptr = <span class="function"><span class="title">realloc</span><span class="params">(ptr, newSize)</span></span>
</code></pre><p>发现ptr为NULL，不是吧，内存泄露了（ptr如果是ptr所指内存的唯一取的方法，那么您将永远失去您对那块内存的控制）。</p>
<p>如果realloc不是这样的万能，我们的生活会不会更和谐？<strong>Don’t write multipurpose functions. Remember K.I.S.S..</strong></p>
<p>当然，作为一般性的考试题，总会有附加题的，请看题：</p>
<pre><code>fseek<span class="list">(<span class="keyword">fpDocument</span>, offset, <span class="number">1</span>)</span><span class="comment">;</span>
</code></pre><p>这不是将fpDocument文件指针定位嘛，有问题？请问，定位在哪？等等，我得去看下fseek函数的说明。。。。N分钟过后。。。。</p>
<p>靠，如果是这样：</p>
<pre><code>fseek<span class="list">(<span class="keyword">fpDocument</span>, offset, SEEK_CUR)</span><span class="comment">;</span>
</code></pre><p>有需要去查fseek函数的说明吗？万恶的bool型参数请参见<a href="http://blog.csdn.net/jay1002008/article/details/6761575" target="_blank" rel="external">博文</a>。Don’t use magic numbers and boolean arguments.</p>
<p>小结：良好的API设计将是您编写bug_free代码的福音，请投入她的怀抱，感受她带来的好处吧~</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="zhujiefirst" itemprop="image"/>
          <p class="site-author-name" itemprop="name">zhujiefirst</p>
        </div>
        <p class="site-description motion-element" itemprop="description">学习总结 思考感悟 知识管理</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhujiefirst</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  

  



  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  
  

  







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
